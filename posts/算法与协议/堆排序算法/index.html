<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.101.0"><title>堆排序算法（图解详细流程） | Gonejack</title><meta name=description content="Gonejack's blog"><link rel=stylesheet href=https://gonejack.github.io/css/simpleness.css><link rel=canonical href=https://gonejack.github.io/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8D%8F%E8%AE%AE/%E5%A0%86%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/><link rel=alternate type=application/rss+xml href title=Gonejack><link href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css rel=stylesheet></head><body class=container><nav class=navigation><div class=nav-left><div class="nav-item nav-title"><a href=https://gonejack.github.io/>Gonejack</a></div><div class="nav-item nav-menu"><a href=/projects/>Projects</a>
<a href=/about/>About</a></div></div><div class="nav-item nav-right fontawesome"><a href=https://github.com/gonejack target=_blank><i title=GitHub class="fab fa-github"></i></a>
<a href=https://gonejack.github.io/index.xml target=_blank><i title=RSS class="fas fa-rss"></i></a></div></nav><article class=post><header class=post-header><h1 style=text-align:center>堆排序算法（图解详细流程）</h1><div class=post-metadata><time datetime=2020-12-01T14:08:40Z>December 01, 2020</time> &nbsp;
<i class="far fa-clock"></i>
9 min
11 s
&nbsp;
<i class="fas fa-folder"></i>
<a href=/categories/%E7%AE%97%E6%B3%95>算法</a>
&nbsp;</div></header><div class=post-text><p>堆排序的时间复杂度O(N*logN),额外空间复杂度O(1)，是一个不稳定性的排序</p><h2 id=一-准备知识>一 准备知识</h2><p>堆的结构可以分为大根堆和小根堆，是一个 <a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a> ，而堆排序是根据堆的这种数据结构设计的一种排序，下面先来看看什么是大根堆和小根堆</p><h3 id=大根堆和小根堆>大根堆和小根堆</h3><p>性质：每个结点的值都大于其左孩子和右孩子结点的值，称之为大根堆；每个结点的值都小于其左孩子和右孩子结点的值，称之为小根堆。如下图</p><p><img src=assets/20180801211245720.jpeg alt>
我们对上面的图中每个数都进行了标记，上面的结构映射成数组就变成了下面这个样子</p><p><img src=assets/20180801213938728.jpeg alt>
还有一个基本概念：查找数组中某个数的父结点和左右孩子结点，比如已知索引为 <strong><em>i</em></strong> 的数，那么</p><ol><li>父结点索引：( <em>i</em> -1)/2（这里计算机中的除以2，省略掉小数）</li><li>左孩子索引：2* <em>i</em> +1</li><li>右孩子索引：2* <em>i</em> +2</li></ol><p>所以上面两个数组可以脑补成堆结构，因为他们满足堆的定义性质：</p><p><strong>大根堆：</strong> arr(i)>arr(2<strong>i+1) && arr(i)>arr(2</strong>i+2)</p><p><strong>小根堆：</strong> arr(i)&lt;arr(2<strong>i+1) && arr(i)&lt;arr(2</strong>i+2)</p><h2 id=二-堆排序基本步骤>二 堆排序基本步骤</h2><h3 id=基本思想>基本思想：</h3><ol><li>首先将待排序的数组构造成一个大根堆，此时，整个数组的最大值就是堆结构的顶端</li><li>将顶端的数与末尾的数交换，此时，末尾的数为最大值，剩余待排序数组个数为n-1</li><li>将剩余的n-1个数再构造成大根堆，再将顶端数与n-1位置的数交换，如此反复执行，便能得到有序数组</li></ol><h3 id=构造堆>构造堆</h3><p>将无序数组构造成一个大根堆（升序用大根堆，降序就用小根堆）</p><p>假设存在以下数组</p><p><img src=assets/20180801223317483.jpeg alt>
主要思路：第一次保证0~0位置大根堆结构（废话），第二次保证0~1位置大根堆结构，第三次保证0~2位置大根堆结构&mldr;直到保证0~n-1位置大根堆结构（每次新插入的数据都与其父结点进行比较，如果插入的数比父结点大，则与父结点交换，否则一直向上交换，直到小于等于父结点，或者来到了顶端）</p><p>插入6的时候，6大于他的父结点3，即arr(1)>arr(0)，则交换；此时，保证了0~1位置是大根堆结构，如下图：</p><p><img src=assets/20180801230208709.jpeg alt>
<em>(友情提示：待交换的数为蓝色，交换后的数为绿色)</em></p><p>插入8的时候，8大于其父结点6，即arr(2)>arr(0),则交换；此时，保证了0~2位置是大根堆结构，如下图</p><p><img src=assets/20180801230101207.jpeg alt>
插入5的时候，5大于其父结点3，则交换，交换之后，5又发现比8小，所以不交换；此时，保证了0~3位置大根堆结构，如下图</p><p><img src=assets/20180801231139446.jpeg alt>
插入7的时候，7大于其父结点5，则交换，交换之后，7又发现比8小，所以不交换；此时 <strong>整个数组已经是大根堆结构</strong></p><p><img src=assets/20180801231815212.jpeg alt></p><h3 id=固定最大值再构造堆>固定最大值再构造堆</h3><p>此时，我们已经得到一个大根堆，下面将顶端的数与最后一位数交换，然后将剩余的数再构造成一个大根堆</p><p><img src=assets/20180802134614132.jpeg alt>
（友情提示：黑色的为固定好的数字，不再参与排序）</p><p>此时最大数8已经来到末尾，则固定不动，后面只需要对顶端的数据进行操作即可，拿顶端的数与其左右孩子较大的数进行比较，如果顶端的数大于其左右孩子较大的数，则停止，如果顶端的数小于其左右孩子较大的数，则交换，然后继续与下面的孩子进行比较</p><p>下图中，5的左右孩子中，左孩子7比右孩子6大，则5与7进行比较，发现5&lt;7，则交换；交换后，发现5已经大于他的左孩子，说明剩余的数已经构成大根堆，后面就是重复固定最大值，然后构造大根堆</p><p><img src=assets/20180802140239955.jpeg alt>
如下图：顶端数7与末尾数3进行交换，固定好7，</p><p><img src=assets/20180802140857754.jpeg alt>
剩余的数开始构造大根堆 ，然后顶端数与末尾数交换，固定最大值再构造大根堆，重复执行上面的操作，最终会得到有序数组</p><p><img src=assets/20180802141542496.jpeg alt></p><h2 id=三-总结>三 总结</h2><p>到这里，大家应该对堆排序都有了自己的见解，我们对上面的流程总结下：</p><ol><li>首先将无需数组构造成一个大根堆（新插入的数据与其父结点比较）</li><li>固定一个最大值，将剩余的数重新构造成一个大根堆，重复这样的过程</li></ol><h2 id=四-代码>四 代码</h2><p>代码中主要两个方法：</p><ol><li>将待排序数组构造成一个大根堆（元素上升）</li><li>固定一个最大值，将剩余的数再构造成一个大根堆（元素下降）</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#998;font-style:italic>//堆排序
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    <span style=color:#000;font-weight:700>public</span> <span style=color:#000;font-weight:700>static</span> <span style=color:#458;font-weight:700>void</span> <span style=color:#900;font-weight:700>heapSort</span><span style=color:#000;font-weight:700>(</span><span style=color:#458;font-weight:700>int</span><span style=color:#000;font-weight:700>[]</span> arr<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#998;font-style:italic>//构造大根堆
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>        heapInsert<span style=color:#000;font-weight:700>(</span>arr<span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>        <span style=color:#458;font-weight:700>int</span> size <span style=color:#000;font-weight:700>=</span> arr<span style=color:#000;font-weight:700>.</span><span style=color:teal>length</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>while</span> <span style=color:#000;font-weight:700>(</span>size <span style=color:#000;font-weight:700>&gt;</span> 1<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>            <span style=color:#998;font-style:italic>//固定最大值
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>            swap<span style=color:#000;font-weight:700>(</span>arr<span style=color:#000;font-weight:700>,</span> 0<span style=color:#000;font-weight:700>,</span> size <span style=color:#000;font-weight:700>-</span> 1<span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>            size<span style=color:#000;font-weight:700>--;</span>
</span></span><span style=display:flex><span>            <span style=color:#998;font-style:italic>//构造大根堆
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>            heapify<span style=color:#000;font-weight:700>(</span>arr<span style=color:#000;font-weight:700>,</span> 0<span style=color:#000;font-weight:700>,</span> size<span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>//构造大根堆（通过新插入的数上升）
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    <span style=color:#000;font-weight:700>public</span> <span style=color:#000;font-weight:700>static</span> <span style=color:#458;font-weight:700>void</span> <span style=color:#900;font-weight:700>heapInsert</span><span style=color:#000;font-weight:700>(</span><span style=color:#458;font-weight:700>int</span><span style=color:#000;font-weight:700>[]</span> arr<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>for</span> <span style=color:#000;font-weight:700>(</span><span style=color:#458;font-weight:700>int</span> i <span style=color:#000;font-weight:700>=</span> 0<span style=color:#000;font-weight:700>;</span> i <span style=color:#000;font-weight:700>&lt;</span> arr<span style=color:#000;font-weight:700>.</span><span style=color:teal>length</span><span style=color:#000;font-weight:700>;</span> i<span style=color:#000;font-weight:700>++)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>            <span style=color:#998;font-style:italic>//当前插入的索引
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>            <span style=color:#458;font-weight:700>int</span> currentIndex <span style=color:#000;font-weight:700>=</span> i<span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>            <span style=color:#998;font-style:italic>//父结点索引
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>            <span style=color:#458;font-weight:700>int</span> fatherIndex <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>(</span>currentIndex <span style=color:#000;font-weight:700>-</span> 1<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>/</span> 2<span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>            <span style=color:#998;font-style:italic>//如果当前插入的值大于其父结点的值,则交换值，并且将索引指向父结点
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>            <span style=color:#998;font-style:italic>//然后继续和上面的父结点值比较，直到不大于父结点，则退出循环
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>            <span style=color:#000;font-weight:700>while</span> <span style=color:#000;font-weight:700>(</span>arr<span style=color:#000;font-weight:700>[</span>currentIndex<span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>&gt;</span> arr<span style=color:#000;font-weight:700>[</span>fatherIndex<span style=color:#000;font-weight:700>])</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>                <span style=color:#998;font-style:italic>//交换当前结点与父结点的值
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>                swap<span style=color:#000;font-weight:700>(</span>arr<span style=color:#000;font-weight:700>,</span> currentIndex<span style=color:#000;font-weight:700>,</span> fatherIndex<span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>                <span style=color:#998;font-style:italic>//将当前索引指向父索引
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>                currentIndex <span style=color:#000;font-weight:700>=</span> fatherIndex<span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>                <span style=color:#998;font-style:italic>//重新计算当前索引的父索引
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>                fatherIndex <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>(</span>currentIndex <span style=color:#000;font-weight:700>-</span> 1<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>/</span> 2<span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>            <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>//将剩余的数构造成大根堆（通过顶端的数下降）
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    <span style=color:#000;font-weight:700>public</span> <span style=color:#000;font-weight:700>static</span> <span style=color:#458;font-weight:700>void</span> <span style=color:#900;font-weight:700>heapify</span><span style=color:#000;font-weight:700>(</span><span style=color:#458;font-weight:700>int</span><span style=color:#000;font-weight:700>[]</span> arr<span style=color:#000;font-weight:700>,</span> <span style=color:#458;font-weight:700>int</span> index<span style=color:#000;font-weight:700>,</span> <span style=color:#458;font-weight:700>int</span> size<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#458;font-weight:700>int</span> left <span style=color:#000;font-weight:700>=</span> 2 <span style=color:#000;font-weight:700>*</span> index <span style=color:#000;font-weight:700>+</span> 1<span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>        <span style=color:#458;font-weight:700>int</span> right <span style=color:#000;font-weight:700>=</span> 2 <span style=color:#000;font-weight:700>*</span> index <span style=color:#000;font-weight:700>+</span> 2<span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>while</span> <span style=color:#000;font-weight:700>(</span>left <span style=color:#000;font-weight:700>&lt;</span> size<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>            <span style=color:#458;font-weight:700>int</span> largestIndex<span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>            <span style=color:#998;font-style:italic>//判断孩子中较大的值的索引（要确保右孩子在size范围之内）
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>            <span style=color:#000;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span>arr<span style=color:#000;font-weight:700>[</span>left<span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>&lt;</span> arr<span style=color:#000;font-weight:700>[</span>right<span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>&amp;&amp;</span> right <span style=color:#000;font-weight:700>&lt;</span> size<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>                largestIndex <span style=color:#000;font-weight:700>=</span> right<span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>            <span style=color:#000;font-weight:700>}</span> <span style=color:#000;font-weight:700>else</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>                largestIndex <span style=color:#000;font-weight:700>=</span> left<span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>            <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>            <span style=color:#998;font-style:italic>//比较父结点的值与孩子中较大的值，并确定最大值的索引
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>            <span style=color:#000;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span>arr<span style=color:#000;font-weight:700>[</span>index<span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>&gt;</span> arr<span style=color:#000;font-weight:700>[</span>largestIndex<span style=color:#000;font-weight:700>])</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>                largestIndex <span style=color:#000;font-weight:700>=</span> index<span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>            <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>            <span style=color:#998;font-style:italic>//如果父结点索引是最大值的索引，那已经是大根堆了，则退出循环
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>            <span style=color:#000;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span>index <span style=color:#000;font-weight:700>==</span> largestIndex<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>                <span style=color:#000;font-weight:700>break</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>            <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>            <span style=color:#998;font-style:italic>//父结点不是最大值，与孩子中较大的值交换
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>            swap<span style=color:#000;font-weight:700>(</span>arr<span style=color:#000;font-weight:700>,</span> largestIndex<span style=color:#000;font-weight:700>,</span> index<span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>            <span style=color:#998;font-style:italic>//将索引指向孩子中较大的值的索引
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>            index <span style=color:#000;font-weight:700>=</span> largestIndex<span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>            <span style=color:#998;font-style:italic>//重新计算交换之后的孩子的索引
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>            left <span style=color:#000;font-weight:700>=</span> 2 <span style=color:#000;font-weight:700>*</span> index <span style=color:#000;font-weight:700>+</span> 1<span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>            right <span style=color:#000;font-weight:700>=</span> 2 <span style=color:#000;font-weight:700>*</span> index <span style=color:#000;font-weight:700>+</span> 2<span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>//交换数组中两个元素的值
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    <span style=color:#000;font-weight:700>public</span> <span style=color:#000;font-weight:700>static</span> <span style=color:#458;font-weight:700>void</span> <span style=color:#900;font-weight:700>swap</span><span style=color:#000;font-weight:700>(</span><span style=color:#458;font-weight:700>int</span><span style=color:#000;font-weight:700>[]</span> arr<span style=color:#000;font-weight:700>,</span> <span style=color:#458;font-weight:700>int</span> i<span style=color:#000;font-weight:700>,</span> <span style=color:#458;font-weight:700>int</span> j<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#458;font-weight:700>int</span> temp <span style=color:#000;font-weight:700>=</span> arr<span style=color:#000;font-weight:700>[</span>i<span style=color:#000;font-weight:700>];</span>
</span></span><span style=display:flex><span>        arr<span style=color:#000;font-weight:700>[</span>i<span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>=</span> arr<span style=color:#000;font-weight:700>[</span>j<span style=color:#000;font-weight:700>];</span>
</span></span><span style=display:flex><span>        arr<span style=color:#000;font-weight:700>[</span>j<span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>=</span> temp<span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p><a href=https://blog.csdn.net/u010452388/article/details/81283998>堆排序算法（图解详细流程）_阿顾的博客-CSDN博客_堆排序</a></p></div><footer class=post-footer><div class=post-tags><i class="fas fa-tags"></i>
<a href=/tags/%E5%A0%86%E6%8E%92%E5%BA%8F>堆排序</a>
&nbsp;
<a href=/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84>数据结构</a>
&nbsp;</div></footer><div class=comments><div class=comments></div></div></article><div class=foot>&copy; 2020 - 2022 &#183;
<a href=/>Gonejack</a> &#183;
Theme <a href=https://github.com/RainerChiang/simpleness>Simpleness</a> Powered by <a href=https://gohugo.io/>Hugo</a> &#183;
<a href=#><i class="fas fa-chevron-up"></i></a></div></body><script src=/js/lazyload.min.js></script>
<script>var lazyImage=new LazyLoad({container:document.getElementById("article")})</script></html>