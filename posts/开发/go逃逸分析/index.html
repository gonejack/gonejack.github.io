<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.101.0"><title>go逃逸分析 | Gonejack</title><meta name=description content="Gonejack's blog"><link rel=stylesheet href=https://gonejack.github.io/css/simpleness.css><link rel=canonical href=https://gonejack.github.io/posts/%E5%BC%80%E5%8F%91/go%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/><link rel=alternate type=application/rss+xml href title=Gonejack><link href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css rel=stylesheet></head><body class=container><nav class=navigation><div class=nav-left><div class="nav-item nav-title"><a href=https://gonejack.github.io/>Gonejack</a></div><div class="nav-item nav-menu"><a href=/projects/>Projects</a>
<a href=/about/>About</a></div></div><div class="nav-item nav-right fontawesome"><a href=https://github.com/gonejack target=_blank><i title=GitHub class="fab fa-github"></i></a>
<a href=https://gonejack.github.io/index.xml target=_blank><i title=RSS class="fas fa-rss"></i></a></div></nav><article class=post><header class=post-header><h1 style=text-align:center>go逃逸分析</h1><div class=post-metadata><time datetime=2020-12-01T13:23:07Z>December 01, 2020</time> &nbsp;
<i class="far fa-clock"></i>
11 min
6 s
&nbsp;
<i class="fas fa-folder"></i>
<a href=/categories/%E5%BC%80%E5%8F%91>开发</a>
&nbsp;</div></header><div class=post-text><h1 id=go-逃逸分析>Go 逃逸分析</h1><h2 id=堆和栈>堆和栈</h2><p>要理解什么是逃逸分析会涉及堆和栈的一些基本知识，如果忘记的同学我们可以简单的回顾一下：</p><ul><li>堆（Heap）：一般来讲是人为手动进行管理，手动申请、分配、释放。堆适合不可预知大小的内存分配，这也意味着为此付出的代价是分配速度较慢，而且会形成内存碎片。</li><li>栈（Stack）：由编译器进行管理，自动申请、分配、释放。一般不会太大，因此栈的分配和回收速度非常快；我们常见的函数参数（不同平台允许存放的数量不同），局部变量等都会存放在栈上。</li></ul><p>栈分配内存只需要两个CPU指令：“PUSH”和“RELEASE”，分配和释放；而堆分配内存首先需要去找到一块大小合适的内存块，之后要通过垃圾回收才能释放。</p><p>通俗比喻的说，<code>栈</code>就如我们去饭馆吃饭，只需要点菜（发出申请）&ndash;》吃吃吃（使用内存）&ndash;》吃饱就跑剩下的交给饭馆（操作系统自动回收），而<code>堆</code>就如在家里做饭，大到家，小到买什么菜，每一个环节都需要自己来实现，但是自由度会大很多。</p><h2 id=什么是逃逸分析>什么是逃逸分析</h2><p>在编译程序优化理论中，逃逸分析是一种确定指针动态范围的方法，简单来说就是分析在程序的哪些地方可以访问到该指针。</p><p>再往简单的说，Go是通过在编译器里做逃逸分析（escape analysis）来决定一个对象放栈上还是放堆上，不逃逸的对象放栈上，可能逃逸的放堆上；即我发现<code>变量</code>在退出函数后没有用了，那么就把丢到栈上，毕竟栈上的内存分配和回收比堆上快很多；反之，函数内的普通变量经过<code>逃逸分析</code>后，发现在函数退出后<code>变量</code>还有在其他地方上引用，那就将<code>变量</code>分配在堆上。做到按需分配（哪里的人民需要我，我就往哪去~~，一个党员的呐喊）。</p><h2 id=为何需要逃逸分析>为何需要逃逸分析</h2><p>ok，了解完<code>堆</code>和<code>栈</code>各自的优缺点后，我们就可以更好的知道<code>逃逸分析</code>存在的目的了：</p><ol><li>减少<code>gc</code>压力，栈上的变量，随着函数退出后系统直接回收，不需要<code>gc</code>标记后再清除。</li><li>减少内存碎片的产生。</li><li>减轻分配堆内存的开销，提高程序的运行速度。</li></ol><h2 id=如何确定是否逃逸>如何确定是否逃逸</h2><p>在<code>Go</code>中通过逃逸分析日志来确定变量是否逃逸，开启逃逸分析日志：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>go run -gcflags <span style=color:#d14>&#39;-m -l&#39;</span> main.go
</span></span></code></pre></div><ul><li><code>-m</code> 会打印出逃逸分析的优化策略，实际上最多总共可以用 4 个 <code>-m</code>，但是信息量较大，一般用 1 个就可以了。</li><li><code>-l</code> 会禁用函数内联，在这里禁用掉<code>内联</code>能更好的观察逃逸情况，减少干扰。</li></ul><h2 id=逃逸案例>逃逸案例</h2><h3 id=案例一取地址发生逃逸>案例一：取地址发生逃逸</h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> UserData <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	Name  <span style=color:#458;font-weight:700>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> info UserData
</span></span><span style=display:flex><span>	info.Name = <span style=color:#d14>&#34;WilburXu&#34;</span>
</span></span><span style=display:flex><span>	_ = <span style=color:#900;font-weight:700>GetUserInfo</span>(info)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>GetUserInfo</span>(userInfo UserData) <span style=color:#000;font-weight:700>*</span>UserData {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>&amp;</span>userInfo
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>执行 <code>go run -gcflags '-m -l' main.go</code> 后返回以下结果：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#998;font-style:italic># command-line-arguments</span>
</span></span><span style=display:flex><span>.<span style=color:#d14>\m</span>ain.go:14:9: &amp;userInfo escapes to heap
</span></span><span style=display:flex><span>.<span style=color:#d14>\m</span>ain.go:13:18: moved to heap: userInfo
</span></span></code></pre></div><blockquote><p>GetUserInfo函数里面的变量 <code>userInfo</code> 逃到堆上了（分配到堆内存空间上了）。</p><p>GetUserInfo 函数的返回值为 *UserData 指针类型，然后 将值变量<code>userInfo</code> 的地址返回，此时编译器会判断该值可能会在函数外使用，就将其分配到了堆上，所以变量<code>userInfo</code>就逃逸了。</p></blockquote><h4 id=优化方案>优化方案</h4><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> info UserData
</span></span><span style=display:flex><span>	info.Name = <span style=color:#d14>&#34;WilburXu&#34;</span>
</span></span><span style=display:flex><span>	_ = <span style=color:#900;font-weight:700>GetUserInfo</span>(<span style=color:#000;font-weight:700>&amp;</span>info)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>GetUserInfo</span>(userInfo <span style=color:#000;font-weight:700>*</span>UserData) <span style=color:#000;font-weight:700>*</span>UserData {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> userInfo
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#998;font-style:italic># command-line-arguments</span>
</span></span><span style=display:flex><span>.<span style=color:#d14>\m</span>ain.go:13:18: leaking param: userInfo to result ~r1 <span style=color:teal>level</span><span style=color:#000;font-weight:700>=</span><span style=color:#099>0</span>
</span></span><span style=display:flex><span>.<span style=color:#d14>\m</span>ain.go:10:18: main &amp;info does not escape
</span></span></code></pre></div><p>对一个变量取地址，可能会被分配到堆上。但是编译器进行逃逸分析后，如果发现到在函数返回后，此变量不会被引用，那么还是会被分配到栈上。套个取址符，就想骗补助？</p><p>编译器傲娇的说：Too young，Too Cool&mldr;！</p><h3 id=案例二-未确定类型>案例二 ：未确定类型</h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> User <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	name <span style=color:#000;font-weight:700>interface</span>{}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	name <span style=color:#000;font-weight:700>:=</span> <span style=color:#d14>&#34;WilburXu&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#900;font-weight:700>MyPrintln</span>(name)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>MyPrintln</span>(one <span style=color:#000;font-weight:700>interface</span>{}) (n <span style=color:#458;font-weight:700>int</span>, err <span style=color:#458;font-weight:700>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> userInfo = <span style=color:#0086b3>new</span>(User)
</span></span><span style=display:flex><span>	userInfo.name = one <span style=color:#998;font-style:italic>// 泛型赋值 逃逸咯
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#000;font-weight:700>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>执行 <code>go run -gcflags '-m -l' main.go</code> 后返回以下结果：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#998;font-style:italic># command-line-arguments</span>
</span></span><span style=display:flex><span>./main.go:12:16: leaking param: one
</span></span><span style=display:flex><span>./main.go:13:20: MyPrintln new<span style=color:#000;font-weight:700>(</span>User<span style=color:#000;font-weight:700>)</span> does not escape
</span></span><span style=display:flex><span>./main.go:9:11: name escapes to heap
</span></span></code></pre></div><p>这里可能有同学会好奇，<code>MyPrintln</code>函数内并没有被引用的便利，为什么变了<code>name</code>会被分配到了<code>堆</code>上呢？</p><p>上一个案例我们知道了，普通的手法想去"骗取补助"，聪明灵利的编译器是不会“上当受骗的噢”；但是对于<code>interface</code>类型，很遗憾，go 编译器或者链接器不可能在编译的时候计算两者的对应关系，因此只能分配到<code>堆</code>上。</p><h3 id=优化方案-1>优化方案</h3><p>将结构体<code>User</code>的成员<code>name</code>的类型、函数<code>MyPringLn</code>参数<code>one</code>的类型改为 <code>string</code>，将得出：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#998;font-style:italic># command-line-arguments</span>
</span></span><span style=display:flex><span>./main.go:12:16: leaking param: one
</span></span><span style=display:flex><span>./main.go:13:20: MyPrintln new<span style=color:#000;font-weight:700>(</span>User<span style=color:#000;font-weight:700>)</span> does not escape
</span></span></code></pre></div><h3 id=拓展分析>拓展分析</h3><p>对于案例二的分析，我们还可以通过反编译命令<code>go tool compile -S main.go</code>查看，会发现如果为<code>interface</code>类型，main主函数在编译后会<code>额外</code>多出以下指令：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#998;font-style:italic># main.go:9 -&gt; MyPrintln(name)</span>
</span></span><span style=display:flex><span>	0x001d <span style=color:#099>00029</span> <span style=color:#000;font-weight:700>(</span>main.go:9<span style=color:#000;font-weight:700>)</span>	PCDATA	<span style=color:teal>$2</span>, <span style=color:teal>$1</span>
</span></span><span style=display:flex><span>	0x001d <span style=color:#099>00029</span> <span style=color:#000;font-weight:700>(</span>main.go:9<span style=color:#000;font-weight:700>)</span>	PCDATA	<span style=color:teal>$0</span>, <span style=color:teal>$1</span>
</span></span><span style=display:flex><span>	0x001d <span style=color:#099>00029</span> <span style=color:#000;font-weight:700>(</span>main.go:9<span style=color:#000;font-weight:700>)</span>	LEAQ	go.string.<span style=color:#d14>&#34;WilburXu&#34;</span><span style=color:#000;font-weight:700>(</span>SB<span style=color:#000;font-weight:700>)</span>, AX
</span></span><span style=display:flex><span>	0x0024 <span style=color:#099>00036</span> <span style=color:#000;font-weight:700>(</span>main.go:9<span style=color:#000;font-weight:700>)</span>	PCDATA	<span style=color:teal>$2</span>, <span style=color:teal>$0</span>
</span></span><span style=display:flex><span>	0x0024 <span style=color:#099>00036</span> <span style=color:#000;font-weight:700>(</span>main.go:9<span style=color:#000;font-weight:700>)</span>	MOVQ	AX, <span style=color:#d14>&#34;&#34;</span>..autotmp_5+32<span style=color:#000;font-weight:700>(</span>SP<span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>	0x0029 <span style=color:#099>00041</span> <span style=color:#000;font-weight:700>(</span>main.go:9<span style=color:#000;font-weight:700>)</span>	MOVQ	<span style=color:teal>$8</span>, <span style=color:#d14>&#34;&#34;</span>..autotmp_5+40<span style=color:#000;font-weight:700>(</span>SP<span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>	0x0032 <span style=color:#099>00050</span> <span style=color:#000;font-weight:700>(</span>main.go:9<span style=color:#000;font-weight:700>)</span>	PCDATA	<span style=color:teal>$2</span>, <span style=color:teal>$1</span>
</span></span><span style=display:flex><span>	0x0032 <span style=color:#099>00050</span> <span style=color:#000;font-weight:700>(</span>main.go:9<span style=color:#000;font-weight:700>)</span>	LEAQ	type.string<span style=color:#000;font-weight:700>(</span>SB<span style=color:#000;font-weight:700>)</span>, AX
</span></span><span style=display:flex><span>	0x0039 <span style=color:#099>00057</span> <span style=color:#000;font-weight:700>(</span>main.go:9<span style=color:#000;font-weight:700>)</span>	PCDATA	<span style=color:teal>$2</span>, <span style=color:teal>$0</span>
</span></span><span style=display:flex><span>	0x0039 <span style=color:#099>00057</span> <span style=color:#000;font-weight:700>(</span>main.go:9<span style=color:#000;font-weight:700>)</span>	MOVQ	AX, <span style=color:#000;font-weight:700>(</span>SP<span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>	0x003d <span style=color:#099>00061</span> <span style=color:#000;font-weight:700>(</span>main.go:9<span style=color:#000;font-weight:700>)</span>	PCDATA	<span style=color:teal>$2</span>, <span style=color:teal>$1</span>
</span></span><span style=display:flex><span>	0x003d <span style=color:#099>00061</span> <span style=color:#000;font-weight:700>(</span>main.go:9<span style=color:#000;font-weight:700>)</span>	LEAQ	<span style=color:#d14>&#34;&#34;</span>..autotmp_5+32<span style=color:#000;font-weight:700>(</span>SP<span style=color:#000;font-weight:700>)</span>, AX
</span></span><span style=display:flex><span>	0x0042 <span style=color:#099>00066</span> <span style=color:#000;font-weight:700>(</span>main.go:9<span style=color:#000;font-weight:700>)</span>	PCDATA	<span style=color:teal>$2</span>, <span style=color:teal>$0</span>
</span></span><span style=display:flex><span>	0x0042 <span style=color:#099>00066</span> <span style=color:#000;font-weight:700>(</span>main.go:9<span style=color:#000;font-weight:700>)</span>	MOVQ	AX, 8<span style=color:#000;font-weight:700>(</span>SP<span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>	0x0047 <span style=color:#099>00071</span> <span style=color:#000;font-weight:700>(</span>main.go:9<span style=color:#000;font-weight:700>)</span>	CALL	runtime.convT2Estring<span style=color:#000;font-weight:700>(</span>SB<span style=color:#000;font-weight:700>)</span>
</span></span></code></pre></div><p>对于<code>Go汇编语法</code>不熟悉的可以参考 <a href=https://studygolang.com/articles/2917>Golang汇编快速指南</a></p><h3 id=案例三间接赋值assignment-to-indirection-escapes>案例三：间接赋值（Assignment to indirection escapes）</h3><p>对某个引用类对象中的引用类成员进行赋值。Go 语言中的引用类数据类型有 <code>func</code>, <code>interface</code>, <code>slice</code>, <code>map</code>, <code>chan</code>, <code>*Type(指针)</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> User <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	name <span style=color:#000;font-weight:700>interface</span>{}
</span></span><span style=display:flex><span>	age <span style=color:#000;font-weight:700>*</span><span style=color:#458;font-weight:700>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> (
</span></span><span style=display:flex><span>		userOne User
</span></span><span style=display:flex><span>		userTwo = <span style=color:#0086b3>new</span>(User)
</span></span><span style=display:flex><span>	)
</span></span><span style=display:flex><span>	userOne.name = <span style=color:#d14>&#34;WilburXuOne&#34;</span>	<span style=color:#998;font-style:italic>// 不逃逸
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	userTwo.name = <span style=color:#d14>&#34;WilburXuTwo&#34;</span>	<span style=color:#998;font-style:italic>// 逃逸
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span>	userOne.age = <span style=color:#0086b3>new</span>(<span style=color:#458;font-weight:700>int</span>)	<span style=color:#998;font-style:italic>// 不逃逸
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	userTwo.age = <span style=color:#0086b3>new</span>(<span style=color:#458;font-weight:700>int</span>)	<span style=color:#998;font-style:italic>// 逃逸
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>}
</span></span></code></pre></div><p>执行 <code>go run -gcflags '-m -l' main.go</code> 后返回以下结果：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#998;font-style:italic># command-line-arguments</span>
</span></span><span style=display:flex><span>.<span style=color:#d14>\m</span>ain.go:14:17: <span style=color:#d14>&#34;WilburXuTwo&#34;</span> escapes to heap
</span></span><span style=display:flex><span>.<span style=color:#d14>\m</span>ain.go:17:19: new<span style=color:#000;font-weight:700>(</span>int<span style=color:#000;font-weight:700>)</span> escapes to heap
</span></span><span style=display:flex><span>.<span style=color:#d14>\m</span>ain.go:11:16: main new<span style=color:#000;font-weight:700>(</span>User<span style=color:#000;font-weight:700>)</span> does not escape
</span></span><span style=display:flex><span>.<span style=color:#d14>\m</span>ain.go:13:17: main <span style=color:#d14>&#34;WilburXuOne&#34;</span> does not escape
</span></span><span style=display:flex><span>.<span style=color:#d14>\m</span>ain.go:16:19: main new<span style=color:#000;font-weight:700>(</span>int<span style=color:#000;font-weight:700>)</span> does not escape
</span></span></code></pre></div><p>为什么这里<code>值</code>类型不会逃逸而<code>引用类型</code>会逃逸呢？这是因为在 <code>userTwo = new(User)</code> 对象的创建时，编译器先是分析<code>userTwo</code> 对象可能分配在<code>堆</code>上，同时成员变量 <code>name</code> 和 <code>age</code> 也为<code>引用类型</code>，为了保证不出现<code>栈</code>回收后，导致对象<code>userTwo</code>的成员值也被回收，所以<code>name</code>和<code>age</code>需要逃逸。</p><p>但是，如果<code>name</code>和<code>age</code>为值类型，那么编译器虽然初步分析<code>userTwo</code>会分配在<code>堆</code>上，但由于<code>main</code>主函数结束后，变量都会被回收，也就是说对象没有被其他引用，那么就都会分配在<code>栈</code>上，所以<code>name</code>和<code>age</code>没有发生逃逸。</p><h4 id=优化建议>优化建议</h4><p>尽量不要将<code>引用对象</code>赋值给<code>引用对象</code>。</p><h2 id=总结>总结</h2><p>不要盲目使用变量的指针作为函数参数，虽然它会减少复制操作。但其实当参数为变量自身的时候，复制是在栈上完成的操作，开销远比变量逃逸后动态地在堆上分配内存少的多。</p><p>Go的编译器就如一个聪明的<code>孩子</code>一般，大多时候在逃逸分析问题上的处理都令人眼前一亮，但有时<code>闹性子</code>的时候处理也是非常粗糙的分析或完全放弃，毕竟这是孩子天性不是吗？ 所以也需要我们在编写代码的时候多多观察，多多留意了。</p><h2 id=参考文章>参考文章</h2><p><a href=http://www.agardner.me/golang/garbage/collection/gc/escape/analysis/2015/10/18/go-escape-analysis.html>http://www.agardner.me/golang/garbage/collection/gc/escape/analysis/2015/10/18/go-escape-analysis.html</a></p><p><a href=https://segmentfault.com/a/1190000019234268>https://segmentfault.com/a/1190000019234268</a></p><p><a href="https://docs.google.com/document/d/1CxgUBPlx9iJzkz9JWkb6tIpTe5q32QDmz8l0BouG0Cw/preview#heading=h.3i6ywlgy4wrw">https://docs.google.com/document/d/1CxgUBPlx9iJzkz9JWkb6tIpTe5q32QDmz8l0BouG0Cw/preview#heading=h.3i6ywlgy4wrw</a></p><p><a href=http://npat-efault.github.io/programming/2016/10/10/escape-analysis-and-interfaces.html>http://npat-efault.github.io/programming/2016/10/10/escape-analysis-and-interfaces.html</a></p><p>[golang 逃逸分析(https://studygolang.com/articles/21880)</p></div><footer class=post-footer><div class=post-tags><i class="fas fa-tags"></i>
<a href=/tags/golang>golang</a>
&nbsp;
<a href=/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86>内存管理</a>
&nbsp;</div><div class=related-posts><h4>Related Posts</h4><i class="fas fa-paperclip"></i>
<a href=/posts/%E5%BC%80%E5%8F%91/go%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E4%B8%8E%E6%A0%88%E5%A0%86%E5%88%86%E9%85%8D%E5%88%86%E6%9E%90/>golang 逃逸分析与栈、堆分配分析</a><br><i class="fas fa-paperclip"></i>
<a href=/posts/%E5%BC%80%E5%8F%91/go%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/>go垃圾回收</a><br><i class="fas fa-paperclip"></i>
<a href=/posts/%E5%BC%80%E5%8F%91/go%E7%A8%8B%E5%BA%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/>go程序初始化顺序</a><br></div></footer><div class=comments><div class=comments></div></div></article><div class=foot>&copy; 2020 - 2022 &#183;
<a href=/>Gonejack</a> &#183;
Theme <a href=https://github.com/RainerChiang/simpleness>Simpleness</a> Powered by <a href=https://gohugo.io/>Hugo</a> &#183;
<a href=#><i class="fas fa-chevron-up"></i></a></div></body><script src=/js/lazyload.min.js></script>
<script>var lazyImage=new LazyLoad({container:document.getElementById("article")})</script></html>