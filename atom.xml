<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>0ccola.𐂂</title>
  
  <subtitle>零度可乐</subtitle>
  <link href="http://gonejack.github.io/atom.xml" rel="self"/>
  
  <link href="http://gonejack.github.io/"/>
  <updated>2020-12-02T08:59:16.327Z</updated>
  <id>http://gonejack.github.io/</id>
  
  <author>
    <name>John Youi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一文读懂 HTTP/2 及 HTTP/3 特性</title>
    <link href="http://gonejack.github.io/2020/12/02/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8D%8F%E8%AE%AE/http-123/"/>
    <id>http://gonejack.github.io/2020/12/02/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8D%8F%E8%AE%AE/http-123/</id>
    <published>2020-12-02T08:57:35.000Z</published>
    <updated>2020-12-02T08:59:16.327Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong> 学习 HTTP/2 与 HTTP/3。</p><ul><li>原文： <a href="https://segmentfault.com/a/1190000018401534">一文读懂 HTTP/2 及 HTTP/3 特性</a></li><li>作者： <a href="https://segmentfault.com/u/langlixingzhou">浪里行舟</a></li></ul><p><em><a href="https://www.fundebug.com/">Fundebug</a> 经授权转载，版权归原作者所有。</em></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>HTTP/2 相比于 HTTP/1，可以说是大幅度提高了网页的性能，只需要升级到该协议就可以减少很多之前需要做的性能优化工作，当然兼容问题以及如何优雅降级应该是国内还不普遍使用的原因之一。</p><p>虽然 HTTP/2 提高了网页的性能，但是并不代表它已经是完美的了，HTTP/3 就是为了解决 HTTP/2 所存在的一些问题而被推出来的。</p><h3 id="一、HTTP-协议"><a href="#一、HTTP-协议" class="headerlink" title="一、HTTP 协议"></a>一、HTTP 协议</h3><p>HTTP 协议是 HyperText Transfer Protocol（超文本传输协议）的缩写，它是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。伴随着计算机网络和浏览器的诞生，HTTP1.0 也随之而来，处于计算机网络中的应用层，HTTP 是建立在 TCP 协议之上，所以 <strong>HTTP 协议的瓶颈及其优化技巧都是基于 TCP 协议本身的特性</strong> ，例如 tcp 建立连接的 3 次握手和断开连接的 4 次挥手以及每次建立连接带来的 RTT 延迟时间。</p><h3 id="二、HTTP-1-x-的缺陷"><a href="#二、HTTP-1-x-的缺陷" class="headerlink" title="二、HTTP/1.x 的缺陷"></a>二、HTTP/1.x 的缺陷</h3><ul><li><p><strong>连接无法复用</strong> ：连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对大量小文件请求影响较大（没有达到最大窗口请求就被终止）。</p><ul><li>HTTP/1.0 传输数据时，每次都需要重新建立连接，增加延迟。</li><li>HTTP/1.1 虽然加入 keep-alive 可以复用一部分连接，但域名分片等情况下仍然需要建立多个 connection，耗费资源，给服务器带来性能压力。</li></ul></li><li><p><strong>Head-Of-Line Blocking（HOLB）</strong> ：导致带宽无法被充分利用，以及后续健康请求被阻塞。 <a href="http://stackoverflow.com/questions/25221954/spdy-head-of-line-blocking">HOLB</a> 是指一系列包（package）因为第一个包被阻塞；当页面中需要请求很多资源的时候，HOLB（队头阻塞）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。</p><ul><li>HTTP 1.0：下个请求必须在前一个请求返回后才能发出， <code>request-response</code> 对按序发生。显然，如果某个请求长时间没有返回，那么接下来的请求就全部阻塞了。</li><li>HTTP 1.1：尝试使用 pipeling 来解决，即浏览器可以一次性发出多个请求（同个域名，同一条 TCP 链接）。但 pipeling 要求返回是按序的，那么前一个请求如果很耗时（比如处理大图片），那么后面的请求即使服务器已经处理完，仍会等待前面的请求处理完才开始按序返回。所以，pipeling 只部分解决了 HOLB。</li></ul></li></ul><p><img src="assets/2019-03-06-1.png"><br>如上图所示，红色圈出来的请求就因域名链接数已超过限制，而被挂起等待了一段时间。</p><ul><li><strong>协议开销大</strong> ： HTTP1.x 在使用时，header 里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求 header 基本不怎么变化，尤其在移动端增加用户流量。</li><li><strong>安全因素</strong> ：HTTP1.x 在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性</li></ul><h3 id="三、SPDY-协议"><a href="#三、SPDY-协议" class="headerlink" title="三、SPDY 协议"></a>三、SPDY 协议</h3><p>因为 HTTP/1.x 的问题，我们会引入雪碧图、将小图内联、使用多个域名等等的方式来提高性能。不过这些优化都绕开了协议，直到 2009 年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。谷歌推出 SPDY，才算是正式改造 HTTP 协议本身。降低延迟，压缩 header 等等，SPDY 的实践证明了这些优化的效果，也最终带来 HTTP/2 的诞生。</p><p>SPDY 协议在 Chrome 浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。</p><h3 id="四、HTTP-2-简介"><a href="#四、HTTP-2-简介" class="headerlink" title="四、HTTP/2 简介"></a>四、HTTP/2 简介</h3><p>2015 年，HTTP_2 发布。HTTP/2 是现行 HTTP 协议（HTTP/1.x）的替代，但它不是重写，HTTP 方法_状态码/语义都与 HTTP/1.x 一样。HTTP/2 基于 SPDY3，专注于 <strong>性能</strong> ，最大的一个目标是在用户和网站间只用一个连接（connection）。</p><p>HTTP/2 由两个规范（Specification）组成：</p><ol><li>Hypertext Transfer Protocol version 2 - RFC7540</li><li>HPACK - Header Compression for HTTP/2 - RFC7541</li></ol><h3 id="五、HTTP-2-新特性"><a href="#五、HTTP-2-新特性" class="headerlink" title="五、HTTP/2 新特性"></a>五、HTTP/2 新特性</h3><h4 id="1-二进制传输"><a href="#1-二进制传输" class="headerlink" title="1. 二进制传输"></a>1. 二进制传输</h4><p>HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。 HTTP / 1 的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。 <strong>HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码</strong> 。</p><p>接下来我们介绍几个重要的概念：</p><ul><li>流：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符（1、2…N）；</li><li>消息：是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。</li><li>帧：HTTP 2.0 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流，承载着特定类型的数据，如 HTTP 首部、负荷，等等</li></ul><p><img src="assets/2019-03-06-2.png"><br>HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。</p><h4 id="2-多路复用"><a href="#2-多路复用" class="headerlink" title="2. 多路复用"></a>2. 多路复用</h4><p>在 HTTP/2 中引入了多路复用的技术。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度。</p><p>大家可以通过 <a href="https://http2.akamai.com/demo">该链接</a> 直观感受下 HTTP/2 比 HTTP/1 到底快了多少。</p><p><img src="assets/2019-03-06-3.gif"><br>在 HTTP/2 中，有了二进制分帧之后，HTTP /2 不再依赖 TCP 链接去实现多流并行了，在 HTTP/2 中：</p><ul><li>同域名下所有通信都在单个连接上完成。</li><li>单个连接可以承载任意数量的双向数据流。</li><li>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。</li></ul><p>这一特性，使性能有了极大提升：</p><ul><li>同个域名只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应,消除了因多个 TCP 连接而带来的延时和内存消耗。</li><li>并行交错地发送多个请求，请求之间互不影响。</li><li>并行交错地发送多个响应，响应之间互不干扰。</li><li>在 HTTP/2 中，每个请求都可以带一个 31bit 的优先值，0 表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。</li></ul><p><img src="assets/2019-03-06-4.png"><br>如上图所示，多路复用的技术可以只通过一个 TCP 连接就可以传输所有的请求数据。</p><p>在 HTTP/1 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。</p><p>为了减少这块的资源消耗并提升性能， HTTP/2 对这些首部采取了压缩策略：</p><ul><li>HTTP/2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；</li><li>首部表在 HTTP/2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新;</li><li>每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值</li></ul><p>例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销</p><p><img src="assets/2019-03-06-5.png"></p><h3 id="4-Server-Push"><a href="#4-Server-Push" class="headerlink" title="4. Server Push"></a>4. Server Push</h3><p>Server Push 即服务端能通过 push 的方式将客户端需要的内容预先推送过去，也叫“cache push”。</p><p>可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 prefetch。<br>例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 时再发送这些请求。</p><p><img src="assets/2019-03-06-6.png"><br>服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送 RST_STREAM 帧来拒收。主动推送也遵守同源策略，换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行。</p><h3 id="六、HTTP-3-新特性"><a href="#六、HTTP-3-新特性" class="headerlink" title="六、HTTP/3 新特性"></a>六、HTTP/3 新特性</h3><h4 id="1-HTTP-3-简介"><a href="#1-HTTP-3-简介" class="headerlink" title="1. HTTP/3 简介"></a>1. HTTP/3 简介</h4><p>虽然 HTTP/2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，主要是底层支撑的 TCP 协议造成的。</p><p>上文提到 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。但当这个连接中出现了丢包的情况，那就会导致 HTTP/2 的表现情况反倒不如 HTTP/1 了。</p><p>因为在出现丢包的情况下，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 HTTP/1.1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。</p><p>那么可能就会有人考虑到去修改 TCP 协议，其实这已经是一件不可能完成的任务了。因为 TCP 存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实。</p><p>基于这个原因， <strong>Google 就更起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上</strong> ，HTTP/3 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC。</p><p>QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，接下来我们重点介绍几个 QUIC 新功能。</p><h4 id="2-QUIC-新功能"><a href="#2-QUIC-新功能" class="headerlink" title="2. QUIC 新功能"></a>2. QUIC 新功能</h4><p>通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。 <strong>0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势</strong> 。那什么是 0RTT 建连呢？</p><p>这里面有两层含义:</p><ul><li>传输层 0RTT 就能建立连接。</li><li>加密层 0RTT 就能建立加密连接。</li></ul><p><img src="assets/2019-03-06-7.png"><br>上图左边是 HTTPS 的一次完全握手的建连过程，需要 3 个 RTT。就算是会话复用也需要至少 2 个 RTT。</p><p>而 QUIC 呢？由于建立在 UDP 的基础上，同时又实现了 0RTT 的安全握手，所以在大部分情况下，只需要 0 个 RTT 就能实现数据发送，在实现前向加密的基础上，并且 0RTT 的成功率相比 TLS 的会话记录单要高很多。</p><p>虽然 HTTP/2 支持了多路复用，但是 TCP 协议终究是没有这个功能的。QUIC 原生就实现了这个功能，并且传输的单个数据流可以保证有序交付且不会影响其他的数据流，这样的技术就解决了之前 TCP 存在的问题。</p><p>同 HTTP2.0 一样，同一条 QUIC 连接上可以创建多个 stream，来发送多个 HTTP 请求，但是，QUIC 是基于 UDP 的，一个连接上的多个 stream 之间没有依赖。比如下图中 stream2 丢了一个 UDP 包，不会影响后面跟着 Stream3 和 Stream4，不存在 TCP 队头阻塞。虽然 stream2 的那个包需要重新传，但是 stream3、stream4 的包无需等待，就可以发给用户。</p><p><img src="assets/2019-03-06-8.png"><br>另外 QUIC 在移动端的表现也会比 TCP 好。因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是 QUIC 是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上。</p><p>TCP 协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也有可能是主动攻击。</p><p>但是 QUIC 的 packet 可以说是武装到了牙齿。除了个别报文比如 PUBLIC_RESET 和 CHLO，所有报文头部都是经过认证的，报文 Body 都是经过加密的。</p><p>这样只要对 QUIC 报文任何修改，接收端都能够及时发现，有效地降低了安全风险。</p><p><img src="assets/2019-03-06-9.png"><br>如上图所示，红色部分是 Stream Frame 的报文头部，有认证。绿色部分是报文内容，全部经过加密。</p><p>QUIC 协议有一个非常独特的特性，称为向前纠错 (Forward Error Correction，FEC)，每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。向前纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传，因为数据重传将会消耗更多的时间(包括确认数据包丢失、请求重传、等待新数据包等步骤的时间消耗)</p><p>假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。 <strong>当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了</strong> 。</p><h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><ul><li>HTTP/1.x 有连接无法复用、队头阻塞、协议开销大和安全因素等多个缺陷</li><li>HTTP/2 通过多路复用、二进制流、Header 压缩等等技术，极大地提高了性能，但是还是存在着问题的</li><li>QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议</li></ul><p><a href="https://blog.fundebug.com/2019/03/07/understand-http2-and-http3/">一文读懂 HTTP/2 及 HTTP/3 特性</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt; 学习 HTTP/2 与 HTTP/3。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原文： &lt;a href=&quot;https://segmentfault.com/a/1190000018401534&quot;&gt;一文读懂 HTTP/2 及 HTTP/3 特性&lt;/</summary>
      
    
    
    
    <category term="协议" scheme="http://gonejack.github.io/categories/%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="网络协议" scheme="http://gonejack.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>P2P 网络核心技术：Gossip 协议</title>
    <link href="http://gonejack.github.io/2020/12/01/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8D%8F%E8%AE%AE/Gossip%E5%8D%8F%E8%AE%AE/"/>
    <id>http://gonejack.github.io/2020/12/01/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8D%8F%E8%AE%AE/Gossip%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-12-01T06:13:04.000Z</published>
    <updated>2020-12-01T06:14:06.540Z</updated>
    
    <content type="html"><![CDATA[<p><img src="assets/v2-7ba8f2ef12354949f18ae1e7560d2e19_720w.jpg"><br><strong>背景</strong></p><p>Gossip protocol 也叫 Epidemic Protocol （流行病协议），实际上它还有很多别名，比如：“流言算法”、“疫情传播算法”等。</p><p>这个协议的作用就像其名字表示的意思一样，非常容易理解，它的方式其实在我们日常生活中也很常见，比如电脑病毒的传播，森林大火，细胞扩散等等。</p><p>Gossip protocol 最早是在 1987 年发表在 ACM 上的论文 《Epidemic Algorithms for Replicated Database Maintenance》中被提出。主要用在分布式数据库系统中各个副本节点同步数据之用，这种场景的一个最大特点就是组成的网络的节点都是对等节点，是非结构化网络，这区别与之前介绍的用于结构化网络中的 DHT 算法 Kadmelia。</p><p>我们知道，很多知名的 P2P 网络或区块链项目，比如 IPFS，Ethereum 等，都使用了 Kadmelia 算法，而大名鼎鼎的 Bitcoin 则是使用了 Gossip 协议来传播交易和区块信息。</p><p>实际上，只要仔细分析一下场景就知道，Ethereum 使用 DHT 算法并不是很合理，因为它使用节点保存整个链数据，不像 IPFS 那样分片保存数据，因此 Ethereum 真正适合的协议应该像 Bitcoin 那样，是 Gossip 协议。</p><p><strong>这里先简单介绍一下 Gossip 协议的执行过程：</strong></p><p>Gossip 过程是由种子节点发起，当一个种子节点有状态需要更新到网络中的其他节点时，它会随机的选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个最终一致性协议。</p><p><strong>Gossip 演示</strong></p><p>现在，我们通过一个具体的实例来深入体会一下 Gossip 传播的完整过程</p><p><strong>为了表述清楚，我们先做一些前提设定</strong></p><p>1、Gossip 是周期性的散播消息，把周期限定为 1 秒</p><p>2、被感染节点随机选择 k 个邻接节点（fan-out）散播消息，这里把 fan-out 设置为 3，每次最多往 3 个节点散播。</p><p>3、每次散播消息都选择尚未发送过的节点进行散播</p><p>4、收到消息的节点不再往发送节点散播，比如 A -&gt; B，那么 B 进行散播的时候，不再发给 A。<br>注意：Gossip 过程是异步的，也就是说发消息的节点不会关注对方是否收到，即不等待响应；不管对方有没有收到，它都会每隔 1 秒向周围节点发消息。异步是它的优点，而消息冗余则是它的缺点。</p><p>这里一共有 16 个节点，节点 1 为初始被感染节点，通过 Gossip 过程，最终所有节点都被感染：</p><p><img src="assets/v2-575e785e7d03ad317e5bce4e36debb03_b.gif"><br><strong>Gossip 的特点（优势）</strong></p><p><strong>1）扩展性</strong></p><p>网络可以允许节点的任意增加和减少，新增加的节点的状态最终会与其他节点一致。</p><p><strong>2）容错</strong></p><p>网络中任何节点的宕机和重启都不会影响 Gossip 消息的传播，Gossip 协议具有天然的分布式系统容错特性。</p><p><strong>3）去中心化</strong></p><p>Gossip 协议不要求任何中心节点，所有节点都可以是对等的，任何一个节点无需知道整个网络状况，只要网络是连通的，任意一个节点就可以把消息散播到全网。</p><p><strong>4）一致性收敛</strong></p><p>Gossip 协议中的消息会以一传十、十传百一样的指数级速度在网络中快速传播，因此系统状态的不一致可以在很快的时间内收敛到一致。消息传播速度达到了 logN。</p><p><strong>5）简单</strong></p><p>Gossip 协议的过程极其简单，实现起来几乎没有太多复杂性。</p><p>Márk Jelasity 在它的 《Gossip》一书中对其进行了归纳：</p><p><img src="assets/v2-c08ff37e40fd993475ee79919531bbe3_b.jpg"><br><strong>Gossip 的缺陷</strong></p><p>分布式网络中，没有一种完美的解决方案，Gossip 协议跟其他协议一样，也有一些不可避免的缺陷，主要是两个：</p><p><strong>1）消息的延迟</strong></p><p>由于 Gossip 协议中，节点只会随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网的，因此使用 Gossip 协议会造成不可避免的消息延迟。不适合用在对实时性要求较高的场景下。</p><p><strong>2）消息冗余</strong></p><p>Gossip 协议规定，节点会定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤，因此就不可避免的存在消息重复发送给同一节点的情况，造成了消息的冗余，同时也增加了收到消息的节点的处理压力。而且，由于是定期发送，因此，即使收到了消息的节点还会反复收到重复消息，加重了消息的冗余。</p><p><strong>Gossip 类型</strong></p><p>Gossip 有两种类型：</p><ul><li>Anti-Entropy（反熵）：以固定的概率传播所有的数据</li><li>Rumor-Mongering（谣言传播）：仅传播新到达的数据</li></ul><p>Anti-Entropy 是 SI model，节点只有两种状态，Suspective 和 Infective，叫做 simple epidemics。</p><p>Rumor-Mongering 是 SIR model，节点有三种状态，Suspective，Infective 和 Removed，叫做 complex epidemics。<br>其实，Anti-entropy 反熵是一个很奇怪的名词，之所以定义成这样，Jelasity 进行了解释，因为 entropy 是指混乱程度（disorder），而在这种模式下可以消除不同节点中数据的 disorder，因此 Anti-entropy 就是 anti-disorder。换句话说，它可以提高系统中节点之间的 similarity。<br>在 SI model 下，一个节点会把所有的数据都跟其他节点共享，以便消除节点之间数据的任何不一致，它可以保证最终、完全的一致。</p><p>由于在 SI model 下消息会不断反复的交换，因此消息数量是非常庞大的，无限制的（unbounded），这对一个系统来说是一个巨大的开销。</p><p>但是在 Rumor Mongering（SIR Model） 模型下，消息可以发送得更频繁，因为消息只包含最新 update，体积更小。而且，一个 Rumor 消息在某个时间点之后会被标记为 removed，并且不再被传播，因此，SIR model 下，系统有一定的概率会不一致。</p><p>而由于，SIR Model 下某个时间点之后消息不再传播，因此消息是有限的，系统开销小。</p><p><strong>Gossip 中的通信模式</strong></p><p>在 Gossip 协议下，网络中两个节点之间有三种通信方式:</p><ul><li>Push: 节点 A 将数据 (key,value,version) 及对应的版本号推送给 B 节点，B 节点更新 A 中比自己新的数据</li><li>Pull：A 仅将数据 key, version 推送给 B，B 将本地比 A 新的数据（Key, value, version）推送给 A，A 更新本地</li><li>Push/Pull：与 Pull 类似，只是多了一步，A 再将本地比 B 新的数据推送给 B，B 则更新本地</li></ul><p>如果把两个节点数据同步一次定义为一个周期，则在一个周期内，Push 需通信 1 次，Pull 需 2 次，Push_Pull 则需 3 次。虽然消息数增加了，但从效果上来讲，Push_Pull 最好，理论上一个周期内可以使两个节点完全一致。直观上，Push/Pull 的收敛速度也是最快的。</p><p><strong>复杂度分析</strong></p><p>对于一个节点数为 N 的网络来说，假设每个 Gossip 周期，新感染的节点都能再感染至少一个新节点，那么 Gossip 协议退化成一个二叉树查找，经过 LogN 个周期之后，感染全网，时间开销是 O(LogN)。由于每个周期，每个节点都会至少发出一次消息，因此，消息复杂度（消息数量 = N * N）是 O(N^2) 。注意，这是 Gossip 理论上最优的收敛速度，但是在实际情况中，最优的收敛速度是很难达到的。</p><p>假设某个节点在第 i 个周期被感染的概率为 pi，第 i+1 个周期被感染的概率为 pi+1 ，</p><p>1）则 Pull 的方式:</p><p><img src="assets/v2-df4e038395c36b430a55a53dbc0b7b5e_b.jpg"><br>2）Push 方式：</p><p><img src="assets/v2-b237352666764df3e3e0f432f4bdcc52_b.jpg"><br>显然 Pull 的收敛速度大于 Push ，而每个节点在每个周期被感染的概率都是固定的 p (0&lt;p&lt;1)，因此 Gossip 算法是基于 p 的平方收敛，也称为概率收敛，这在众多的一致性算法中是非常独特的。<br>全文完！</p><p><a href="https://zhuanlan.zhihu.com/p/41228196">P2P 网络核心技术：Gossip 协议</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;assets/v2-7ba8f2ef12354949f18ae1e7560d2e19_720w.jpg&quot;&gt;&lt;br&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Gossip protocol 也叫 Epidemic Protocol （流行病协议</summary>
      
    
    
    
    <category term="算法" scheme="http://gonejack.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="分布式协议" scheme="http://gonejack.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="网络协议" scheme="http://gonejack.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>堆排序算法（图解详细流程）</title>
    <link href="http://gonejack.github.io/2020/12/01/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8D%8F%E8%AE%AE/%E5%A0%86%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://gonejack.github.io/2020/12/01/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8D%8F%E8%AE%AE/%E5%A0%86%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2020-12-01T06:08:40.000Z</published>
    <updated>2020-12-01T06:15:22.517Z</updated>
    
    <content type="html"><![CDATA[<p>堆排序的时间复杂度O(N*logN),额外空间复杂度O(1)，是一个不稳定性的排序</p><h2 id="一-准备知识"><a href="#一-准备知识" class="headerlink" title="一 准备知识"></a>一 准备知识</h2><p>堆的结构可以分为大根堆和小根堆，是一个 <a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a> ，而堆排序是根据堆的这种数据结构设计的一种排序，下面先来看看什么是大根堆和小根堆</p><h3 id="大根堆和小根堆"><a href="#大根堆和小根堆" class="headerlink" title="大根堆和小根堆"></a>大根堆和小根堆</h3><p>性质：每个结点的值都大于其左孩子和右孩子结点的值，称之为大根堆；每个结点的值都小于其左孩子和右孩子结点的值，称之为小根堆。如下图</p><p><img src="assets/20180801211245720.jpeg"><br>我们对上面的图中每个数都进行了标记，上面的结构映射成数组就变成了下面这个样子</p><p><img src="assets/20180801213938728.jpeg"><br>还有一个基本概念：查找数组中某个数的父结点和左右孩子结点，比如已知索引为 <strong><em>i</em></strong> 的数，那么</p><ol><li>父结点索引：( <em>i</em> -1)/2（这里计算机中的除以2，省略掉小数）</li><li>左孩子索引：2* <em>i</em> +1</li><li>右孩子索引：2* <em>i</em> +2</li></ol><p>所以上面两个数组可以脑补成堆结构，因为他们满足堆的定义性质：</p><p><strong>大根堆：</strong> arr(i)&gt;arr(2<strong>i+1) &amp;&amp; arr(i)&gt;arr(2</strong>i+2)</p><p><strong>小根堆：</strong> arr(i)&lt;arr(2<strong>i+1) &amp;&amp; arr(i)&lt;arr(2</strong>i+2)</p><h2 id="二-堆排序基本步骤"><a href="#二-堆排序基本步骤" class="headerlink" title="二 堆排序基本步骤"></a>二 堆排序基本步骤</h2><h3 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h3><ol><li>首先将待排序的数组构造成一个大根堆，此时，整个数组的最大值就是堆结构的顶端</li><li>将顶端的数与末尾的数交换，此时，末尾的数为最大值，剩余待排序数组个数为n-1</li><li>将剩余的n-1个数再构造成大根堆，再将顶端数与n-1位置的数交换，如此反复执行，便能得到有序数组</li></ol><h3 id="构造堆"><a href="#构造堆" class="headerlink" title="构造堆"></a>构造堆</h3><p>将无序数组构造成一个大根堆（升序用大根堆，降序就用小根堆）</p><p>假设存在以下数组</p><p><img src="assets/20180801223317483.jpeg"><br>主要思路：第一次保证0<del>0位置大根堆结构（废话），第二次保证0</del>1位置大根堆结构，第三次保证0<del>2位置大根堆结构…直到保证0</del>n-1位置大根堆结构（每次新插入的数据都与其父结点进行比较，如果插入的数比父结点大，则与父结点交换，否则一直向上交换，直到小于等于父结点，或者来到了顶端）</p><p>插入6的时候，6大于他的父结点3，即arr(1)&gt;arr(0)，则交换；此时，保证了0~1位置是大根堆结构，如下图：</p><p><img src="assets/20180801230208709.jpeg"><br>                 <em>(友情提示：待交换的数为蓝色，交换后的数为绿色)</em></p><p>插入8的时候，8大于其父结点6，即arr(2)&gt;arr(0),则交换；此时，保证了0~2位置是大根堆结构，如下图</p><p><img src="assets/20180801230101207.jpeg"><br>插入5的时候，5大于其父结点3，则交换，交换之后，5又发现比8小，所以不交换；此时，保证了0~3位置大根堆结构，如下图</p><p><img src="assets/20180801231139446.jpeg"><br>插入7的时候，7大于其父结点5，则交换，交换之后，7又发现比8小，所以不交换；此时 <strong>整个数组已经是大根堆结构</strong>  </p><p><img src="assets/20180801231815212.jpeg"></p><h3 id="固定最大值再构造堆"><a href="#固定最大值再构造堆" class="headerlink" title="固定最大值再构造堆"></a>固定最大值再构造堆</h3><p>此时，我们已经得到一个大根堆，下面将顶端的数与最后一位数交换，然后将剩余的数再构造成一个大根堆</p><p><img src="assets/20180802134614132.jpeg"><br>（友情提示：黑色的为固定好的数字，不再参与排序）</p><p>此时最大数8已经来到末尾，则固定不动，后面只需要对顶端的数据进行操作即可，拿顶端的数与其左右孩子较大的数进行比较，如果顶端的数大于其左右孩子较大的数，则停止，如果顶端的数小于其左右孩子较大的数，则交换，然后继续与下面的孩子进行比较</p><p>下图中，5的左右孩子中，左孩子7比右孩子6大，则5与7进行比较，发现5&lt;7，则交换；交换后，发现5已经大于他的左孩子，说明剩余的数已经构成大根堆，后面就是重复固定最大值，然后构造大根堆</p><p><img src="assets/20180802140239955.jpeg"><br>如下图：顶端数7与末尾数3进行交换，固定好7，</p><p><img src="assets/20180802140857754.jpeg"><br>剩余的数开始构造大根堆 ，然后顶端数与末尾数交换，固定最大值再构造大根堆，重复执行上面的操作，最终会得到有序数组</p><p><img src="assets/20180802141542496.jpeg"></p><h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三 总结"></a>三 总结</h2><p>到这里，大家应该对堆排序都有了自己的见解，我们对上面的流程总结下：</p><ol><li>首先将无需数组构造成一个大根堆（新插入的数据与其父结点比较）</li><li>固定一个最大值，将剩余的数重新构造成一个大根堆，重复这样的过程</li></ol><h2 id="四-代码"><a href="#四-代码" class="headerlink" title="四 代码"></a>四 代码</h2><p>代码中主要两个方法：</p><ol><li>将待排序数组构造成一个大根堆（元素上升）</li><li>固定一个最大值，将剩余的数再构造成一个大根堆（元素下降）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造大根堆</span></span><br><span class="line">        heapInsert(arr);</span><br><span class="line">        <span class="keyword">int</span> size = arr.length;</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//固定最大值</span></span><br><span class="line">            swap(arr, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">            size--;</span><br><span class="line">            <span class="comment">//构造大根堆</span></span><br><span class="line">            heapify(arr, <span class="number">0</span>, size);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造大根堆（通过新插入的数上升）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//当前插入的索引</span></span><br><span class="line">            <span class="keyword">int</span> currentIndex = i;</span><br><span class="line">            <span class="comment">//父结点索引</span></span><br><span class="line">            <span class="keyword">int</span> fatherIndex = (currentIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//如果当前插入的值大于其父结点的值,则交换值，并且将索引指向父结点</span></span><br><span class="line">            <span class="comment">//然后继续和上面的父结点值比较，直到不大于父结点，则退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (arr[currentIndex] &gt; arr[fatherIndex]) &#123;</span><br><span class="line">                <span class="comment">//交换当前结点与父结点的值</span></span><br><span class="line">                swap(arr, currentIndex, fatherIndex);</span><br><span class="line">                <span class="comment">//将当前索引指向父索引</span></span><br><span class="line">                currentIndex = fatherIndex;</span><br><span class="line">                <span class="comment">//重新计算当前索引的父索引</span></span><br><span class="line">                fatherIndex = (currentIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将剩余的数构造成大根堆（通过顶端的数下降）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; size) &#123;</span><br><span class="line">            <span class="keyword">int</span> largestIndex;</span><br><span class="line">            <span class="comment">//判断孩子中较大的值的索引（要确保右孩子在size范围之内）</span></span><br><span class="line">            <span class="keyword">if</span> (arr[left] &lt; arr[right] &amp;&amp; right &lt; size) &#123;</span><br><span class="line">                largestIndex = right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                largestIndex = left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较父结点的值与孩子中较大的值，并确定最大值的索引</span></span><br><span class="line">            <span class="keyword">if</span> (arr[index] &gt; arr[largestIndex]) &#123;</span><br><span class="line">                largestIndex = index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果父结点索引是最大值的索引，那已经是大根堆了，则退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (index == largestIndex) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//父结点不是最大值，与孩子中较大的值交换</span></span><br><span class="line">            swap(arr, largestIndex, index);</span><br><span class="line">            <span class="comment">//将索引指向孩子中较大的值的索引</span></span><br><span class="line">            index = largestIndex;</span><br><span class="line">            <span class="comment">//重新计算交换之后的孩子的索引</span></span><br><span class="line">            left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">            right = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换数组中两个元素的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/u010452388/article/details/81283998">堆排序算法（图解详细流程）_阿顾的博客-CSDN博客_堆排序</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;堆排序的时间复杂度O(N*logN),额外空间复杂度O(1)，是一个不稳定性的排序&lt;/p&gt;
&lt;h2 id=&quot;一-准备知识&quot;&gt;&lt;a href=&quot;#一-准备知识&quot; class=&quot;headerlink&quot; title=&quot;一 准备知识&quot;&gt;&lt;/a&gt;一 准备知识&lt;/h2&gt;&lt;p&gt;堆的结构可</summary>
      
    
    
    
    <category term="算法" scheme="http://gonejack.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="堆排序" scheme="http://gonejack.github.io/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
    <category term="数据结构" scheme="http://gonejack.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>go逃逸分析</title>
    <link href="http://gonejack.github.io/2020/12/01/%E5%BC%80%E5%8F%91/go%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"/>
    <id>http://gonejack.github.io/2020/12/01/%E5%BC%80%E5%8F%91/go%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</id>
    <published>2020-12-01T05:23:07.000Z</published>
    <updated>2020-12-01T05:25:21.106Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go-逃逸分析"><a href="#Go-逃逸分析" class="headerlink" title="Go 逃逸分析"></a>Go 逃逸分析</h1><h2 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h2><p>要理解什么是逃逸分析会涉及堆和栈的一些基本知识，如果忘记的同学我们可以简单的回顾一下：</p><ul><li>堆（Heap）：一般来讲是人为手动进行管理，手动申请、分配、释放。堆适合不可预知大小的内存分配，这也意味着为此付出的代价是分配速度较慢，而且会形成内存碎片。</li><li>栈（Stack）：由编译器进行管理，自动申请、分配、释放。一般不会太大，因此栈的分配和回收速度非常快；我们常见的函数参数（不同平台允许存放的数量不同），局部变量等都会存放在栈上。</li></ul><p>栈分配内存只需要两个CPU指令：“PUSH”和“RELEASE”，分配和释放；而堆分配内存首先需要去找到一块大小合适的内存块，之后要通过垃圾回收才能释放。</p><p>通俗比喻的说，<code>栈</code>就如我们去饭馆吃饭，只需要点菜（发出申请）–》吃吃吃（使用内存）–》吃饱就跑剩下的交给饭馆（操作系统自动回收），而<code>堆</code>就如在家里做饭，大到家，小到买什么菜，每一个环节都需要自己来实现，但是自由度会大很多。</p><h2 id="什么是逃逸分析"><a href="#什么是逃逸分析" class="headerlink" title="什么是逃逸分析"></a>什么是逃逸分析</h2><p>在编译程序优化理论中，逃逸分析是一种确定指针动态范围的方法，简单来说就是分析在程序的哪些地方可以访问到该指针。</p><p>再往简单的说，Go是通过在编译器里做逃逸分析（escape analysis）来决定一个对象放栈上还是放堆上，不逃逸的对象放栈上，可能逃逸的放堆上；即我发现<code>变量</code>在退出函数后没有用了，那么就把丢到栈上，毕竟栈上的内存分配和回收比堆上快很多；反之，函数内的普通变量经过<code>逃逸分析</code>后，发现在函数退出后<code>变量</code>还有在其他地方上引用，那就将<code>变量</code>分配在堆上。做到按需分配（哪里的人民需要我，我就往哪去~~，一个党员的呐喊）。</p><h2 id="为何需要逃逸分析"><a href="#为何需要逃逸分析" class="headerlink" title="为何需要逃逸分析"></a>为何需要逃逸分析</h2><p>ok，了解完<code>堆</code>和<code>栈</code>各自的优缺点后，我们就可以更好的知道<code>逃逸分析</code>存在的目的了：</p><ol><li>减少<code>gc</code>压力，栈上的变量，随着函数退出后系统直接回收，不需要<code>gc</code>标记后再清除。</li><li>减少内存碎片的产生。</li><li>减轻分配堆内存的开销，提高程序的运行速度。</li></ol><h2 id="如何确定是否逃逸"><a href="#如何确定是否逃逸" class="headerlink" title="如何确定是否逃逸"></a>如何确定是否逃逸</h2><p>在<code>Go</code>中通过逃逸分析日志来确定变量是否逃逸，开启逃逸分析日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run -gcflags &#x27;-m -l&#x27; main.go</span><br></pre></td></tr></table></figure><ul><li><code>-m</code> 会打印出逃逸分析的优化策略，实际上最多总共可以用 4 个 <code>-m</code>，但是信息量较大，一般用 1 个就可以了。</li><li><code>-l</code> 会禁用函数内联，在这里禁用掉<code>内联</code>能更好的观察逃逸情况，减少干扰。</li></ul><h2 id="逃逸案例"><a href="#逃逸案例" class="headerlink" title="逃逸案例"></a>逃逸案例</h2><h3 id="案例一：取地址发生逃逸"><a href="#案例一：取地址发生逃逸" class="headerlink" title="案例一：取地址发生逃逸"></a>案例一：取地址发生逃逸</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserData <span class="keyword">struct</span> &#123;</span><br><span class="line">Name  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> info UserData</span><br><span class="line">info.Name = <span class="string">&quot;WilburXu&quot;</span></span><br><span class="line">_ = GetUserInfo(info)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserInfo</span><span class="params">(userInfo UserData)</span> *<span class="title">UserData</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;userInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>go run -gcflags &#39;-m -l&#39; main.go</code> 后返回以下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> command-line-arguments</span></span><br><span class="line">.\main.go:14:9: &amp;userInfo escapes to heap</span><br><span class="line">.\main.go:13:18: moved to heap: userInfo</span><br></pre></td></tr></table></figure><blockquote><p>GetUserInfo函数里面的变量 <code>userInfo</code> 逃到堆上了（分配到堆内存空间上了）。</p><p>GetUserInfo 函数的返回值为 *UserData 指针类型，然后 将值变量<code>userInfo</code> 的地址返回，此时编译器会判断该值可能会在函数外使用，就将其分配到了堆上，所以变量<code>userInfo</code>就逃逸了。</p></blockquote><h4 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> info UserData</span><br><span class="line">info.Name = <span class="string">&quot;WilburXu&quot;</span></span><br><span class="line">_ = GetUserInfo(&amp;info)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserInfo</span><span class="params">(userInfo *UserData)</span> *<span class="title">UserData</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> userInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> command-line-arguments</span></span><br><span class="line">.\main.go:13:18: leaking param: userInfo to result ~r1 level=0</span><br><span class="line">.\main.go:10:18: main &amp;info does not escape</span><br></pre></td></tr></table></figure><p>对一个变量取地址，可能会被分配到堆上。但是编译器进行逃逸分析后，如果发现到在函数返回后，此变量不会被引用，那么还是会被分配到栈上。套个取址符，就想骗补助？</p><p>编译器傲娇的说：Too young，Too Cool…！</p><h3 id="案例二-：未确定类型"><a href="#案例二-：未确定类型" class="headerlink" title="案例二 ：未确定类型"></a>案例二 ：未确定类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">name := <span class="string">&quot;WilburXu&quot;</span></span><br><span class="line">MyPrintln(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyPrintln</span><span class="params">(one <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> userInfo = <span class="built_in">new</span>(User)</span><br><span class="line">userInfo.name = one <span class="comment">// 泛型赋值 逃逸咯</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>go run -gcflags &#39;-m -l&#39; main.go</code> 后返回以下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> command-line-arguments</span></span><br><span class="line">./main.go:12:16: leaking param: one</span><br><span class="line">./main.go:13:20: MyPrintln new(User) does not escape</span><br><span class="line">./main.go:9:11: name escapes to heap</span><br></pre></td></tr></table></figure><p>这里可能有同学会好奇，<code>MyPrintln</code>函数内并没有被引用的便利，为什么变了<code>name</code>会被分配到了<code>堆</code>上呢？</p><p>上一个案例我们知道了，普通的手法想去”骗取补助”，聪明灵利的编译器是不会“上当受骗的噢”；但是对于<code>interface</code>类型，很遗憾，go 编译器或者链接器不可能在编译的时候计算两者的对应关系，因此只能分配到<code>堆</code>上。</p><h3 id="优化方案-1"><a href="#优化方案-1" class="headerlink" title="优化方案"></a>优化方案</h3><p>将结构体<code>User</code>的成员<code>name</code>的类型、函数<code>MyPringLn</code>参数<code>one</code>的类型改为 <code>string</code>，将得出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> command-line-arguments</span></span><br><span class="line">./main.go:12:16: leaking param: one</span><br><span class="line">./main.go:13:20: MyPrintln new(User) does not escape</span><br></pre></td></tr></table></figure><h3 id="拓展分析"><a href="#拓展分析" class="headerlink" title="拓展分析"></a>拓展分析</h3><p>对于案例二的分析，我们还可以通过反编译命令<code>go tool compile -S main.go</code>查看，会发现如果为<code>interface</code>类型，main主函数在编译后会<code>额外</code>多出以下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> main.go:9 -&gt; MyPrintln(name)</span></span><br><span class="line">0x001d 00029 (main.go:9)PCDATA$2, $1</span><br><span class="line">0x001d 00029 (main.go:9)PCDATA$0, $1</span><br><span class="line">0x001d 00029 (main.go:9)LEAQgo.string.&quot;WilburXu&quot;(SB), AX</span><br><span class="line">0x0024 00036 (main.go:9)PCDATA$2, $0</span><br><span class="line">0x0024 00036 (main.go:9)MOVQAX, &quot;&quot;..autotmp_5+32(SP)</span><br><span class="line">0x0029 00041 (main.go:9)MOVQ$8, &quot;&quot;..autotmp_5+40(SP)</span><br><span class="line">0x0032 00050 (main.go:9)PCDATA$2, $1</span><br><span class="line">0x0032 00050 (main.go:9)LEAQtype.string(SB), AX</span><br><span class="line">0x0039 00057 (main.go:9)PCDATA$2, $0</span><br><span class="line">0x0039 00057 (main.go:9)MOVQAX, (SP)</span><br><span class="line">0x003d 00061 (main.go:9)PCDATA$2, $1</span><br><span class="line">0x003d 00061 (main.go:9)LEAQ&quot;&quot;..autotmp_5+32(SP), AX</span><br><span class="line">0x0042 00066 (main.go:9)PCDATA$2, $0</span><br><span class="line">0x0042 00066 (main.go:9)MOVQAX, 8(SP)</span><br><span class="line">0x0047 00071 (main.go:9)CALLruntime.convT2Estring(SB)</span><br></pre></td></tr></table></figure><p>对于<code>Go汇编语法</code>不熟悉的可以参考 <a href="https://studygolang.com/articles/2917">Golang汇编快速指南</a></p><h3 id="案例三：间接赋值（Assignment-to-indirection-escapes）"><a href="#案例三：间接赋值（Assignment-to-indirection-escapes）" class="headerlink" title="案例三：间接赋值（Assignment to indirection escapes）"></a>案例三：间接赋值（Assignment to indirection escapes）</h3><p>对某个引用类对象中的引用类成员进行赋值。Go 语言中的引用类数据类型有 <code>func</code>, <code>interface</code>, <code>slice</code>, <code>map</code>, <code>chan</code>, <code>*Type(指针)</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">age *<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">userOne User</span><br><span class="line">userTwo = <span class="built_in">new</span>(User)</span><br><span class="line">)</span><br><span class="line">userOne.name = <span class="string">&quot;WilburXuOne&quot;</span><span class="comment">// 不逃逸</span></span><br><span class="line">userTwo.name = <span class="string">&quot;WilburXuTwo&quot;</span><span class="comment">// 逃逸</span></span><br><span class="line"></span><br><span class="line">userOne.age = <span class="built_in">new</span>(<span class="keyword">int</span>)<span class="comment">// 不逃逸</span></span><br><span class="line">userTwo.age = <span class="built_in">new</span>(<span class="keyword">int</span>)<span class="comment">// 逃逸</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>go run -gcflags &#39;-m -l&#39; main.go</code> 后返回以下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> command-line-arguments</span></span><br><span class="line">.\main.go:14:17: &quot;WilburXuTwo&quot; escapes to heap</span><br><span class="line">.\main.go:17:19: new(int) escapes to heap</span><br><span class="line">.\main.go:11:16: main new(User) does not escape</span><br><span class="line">.\main.go:13:17: main &quot;WilburXuOne&quot; does not escape</span><br><span class="line">.\main.go:16:19: main new(int) does not escape</span><br></pre></td></tr></table></figure><p>为什么这里<code>值</code>类型不会逃逸而<code>引用类型</code>会逃逸呢？这是因为在 <code>userTwo = new(User)</code> 对象的创建时，编译器先是分析<code>userTwo</code> 对象可能分配在<code>堆</code>上，同时成员变量 <code>name</code> 和 <code>age</code> 也为<code>引用类型</code>，为了保证不出现<code>栈</code>回收后，导致对象<code>userTwo</code>的成员值也被回收，所以<code>name</code>和<code>age</code>需要逃逸。</p><p>但是，如果<code>name</code>和<code>age</code>为值类型，那么编译器虽然初步分析<code>userTwo</code>会分配在<code>堆</code>上，但由于<code>main</code>主函数结束后，变量都会被回收，也就是说对象没有被其他引用，那么就都会分配在<code>栈</code>上，所以<code>name</code>和<code>age</code>没有发生逃逸。</p><h4 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h4><p>尽量不要将<code>引用对象</code>赋值给<code>引用对象</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不要盲目使用变量的指针作为函数参数，虽然它会减少复制操作。但其实当参数为变量自身的时候，复制是在栈上完成的操作，开销远比变量逃逸后动态地在堆上分配内存少的多。</p><p>Go的编译器就如一个聪明的<code>孩子</code>一般，大多时候在逃逸分析问题上的处理都令人眼前一亮，但有时<code>闹性子</code>的时候处理也是非常粗糙的分析或完全放弃，毕竟这是孩子天性不是吗？ 所以也需要我们在编写代码的时候多多观察，多多留意了。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.agardner.me/golang/garbage/collection/gc/escape/analysis/2015/10/18/go-escape-analysis.html">http://www.agardner.me/golang/garbage/collection/gc/escape/analysis/2015/10/18/go-escape-analysis.html</a></p><p><a href="https://segmentfault.com/a/1190000019234268">https://segmentfault.com/a/1190000019234268</a></p><p><a href="https://docs.google.com/document/d/1CxgUBPlx9iJzkz9JWkb6tIpTe5q32QDmz8l0BouG0Cw/preview#heading=h.3i6ywlgy4wrw">https://docs.google.com/document/d/1CxgUBPlx9iJzkz9JWkb6tIpTe5q32QDmz8l0BouG0Cw/preview#heading=h.3i6ywlgy4wrw</a></p><p><a href="http://npat-efault.github.io/programming/2016/10/10/escape-analysis-and-interfaces.html">http://npat-efault.github.io/programming/2016/10/10/escape-analysis-and-interfaces.html</a></p><p>[golang 逃逸分析(<a href="https://studygolang.com/articles/21880">https://studygolang.com/articles/21880</a>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Go-逃逸分析&quot;&gt;&lt;a href=&quot;#Go-逃逸分析&quot; class=&quot;headerlink&quot; title=&quot;Go 逃逸分析&quot;&gt;&lt;/a&gt;Go 逃逸分析&lt;/h1&gt;&lt;h2 id=&quot;堆和栈&quot;&gt;&lt;a href=&quot;#堆和栈&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="开发" scheme="http://gonejack.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="golang" scheme="http://gonejack.github.io/tags/golang/"/>
    
    <category term="内存管理" scheme="http://gonejack.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>golang 逃逸分析与栈、堆分配分析</title>
    <link href="http://gonejack.github.io/2020/12/01/%E5%BC%80%E5%8F%91/go%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E4%B8%8E%E6%A0%88%E3%80%81%E5%A0%86%E5%88%86%E9%85%8D%E5%88%86%E6%9E%90/"/>
    <id>http://gonejack.github.io/2020/12/01/%E5%BC%80%E5%8F%91/go%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E4%B8%8E%E6%A0%88%E3%80%81%E5%A0%86%E5%88%86%E9%85%8D%E5%88%86%E6%9E%90/</id>
    <published>2020-12-01T05:19:18.000Z</published>
    <updated>2020-12-01T05:22:57.454Z</updated>
    
    <content type="html"><![CDATA[<p>我们在写 golang 代码时候定义变量，那么一个很常见的问题，申请的变量保存在哪里呢？栈？还是堆？会不会有一些特殊例子？这篇文章我们就来探索下具体的case以及如何做分析。</p><p>还是从实际使用场景出发：</p><h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">ID     <span class="keyword">int64</span></span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">Avatar <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserInfo</span><span class="params">()</span> *<span class="title">User</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;User&#123;</span><br><span class="line">ID: <span class="number">666666</span>,</span><br><span class="line">Name: <span class="string">&quot;sim lou&quot;</span>,</span><br><span class="line">Avatar: <span class="string">&quot;https://www.baidu.com/avatar/666666&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">u := GetUserInfo()</span><br><span class="line"><span class="built_in">println</span>(u.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里GetUserInfo 函数里面的 User 对象是存储在函数栈上还是堆上？</p><h2 id="什么是堆？什么是栈？"><a href="#什么是堆？什么是栈？" class="headerlink" title="什么是堆？什么是栈？"></a>什么是堆？什么是栈？</h2><p>简单说：</p><ul><li>堆：一般来讲是人为手动进行管理，手动申请、分配、释放。一般所涉及的内存大小并不定，一般会存放较大的对象。另外其分配相对慢，涉及到的指令动作也相对多</li><li>栈：由编译器进行管理，自动申请、分配、释放。一般不会太大，我们常见的函数参数（不同平台允许存放的数量不同），局部变量等等都会存放在栈上</li></ul><p>今天我们介绍的 Go 语言，它的堆栈分配是通过 Compiler 进行分析，GC 去管理的，而对其的分析选择动作就是今天探讨的重点</p><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>逃逸分析是一种确定指针动态范围的方法，简单来说就是分析在程序的哪些地方可以访问到该指针。</p><p>通俗地讲，逃逸分析就是确定一个变量要放堆上还是栈上，规则如下：</p><ul><li>是否有在其他地方（非局部）被引用。只要有可能被引用了，那么它一定分配到堆上。否则分配到栈上</li><li>即使没有被外部引用，但对象过大，无法存放在栈区上。依然有可能分配到堆上</li></ul><p>对此你可以理解为，逃逸分析是编译器用于决定变量分配到堆上还是栈上的一种行为。</p><h2 id="在什么阶段确立逃逸"><a href="#在什么阶段确立逃逸" class="headerlink" title="在什么阶段确立逃逸"></a>在什么阶段确立逃逸</h2><p>go 在编译阶段确立逃逸，注意并不是在运行时</p><h2 id="为什么需要逃逸"><a href="#为什么需要逃逸" class="headerlink" title="为什么需要逃逸"></a>为什么需要逃逸</h2><p>其实就是为了尽可能在栈上分配内存，我们可以反过来想，如果变量都分配到堆上了会出现什么事情？例如：</p><ul><li>垃圾回收（GC）的压力不断增大</li><li>申请、分配、回收内存的系统开销增大（相对于栈）</li><li>动态分配产生一定量的内存碎片</li></ul><p>其实总的来说，就是频繁申请、分配堆内存是有一定 “代价” 的。会影响应用程序运行的效率，间接影响到整体系统。因此 “按需分配” 最大限度的灵活利用资源，才是正确的治理之道。这就是为什么需要逃逸分析的原因，你觉得呢？</p><h2 id="go怎么确定是否逃逸"><a href="#go怎么确定是否逃逸" class="headerlink" title="go怎么确定是否逃逸"></a>go怎么确定是否逃逸</h2><p>可以看到详细的逃逸分析过程。而指令集 -gcflags 用于将标识参数传递给 Go 编译器，涉及如下：</p><ul><li>-m 会打印出逃逸分析的优化策略，实际上最多总共可以用 4 个 -m，但是信息量较大，一般用 1 个就可以了</li><li>-l 会禁用函数内联，在这里禁用掉 inline 能更好的观察逃逸情况，减少干扰</li></ul><p><code>$ go build -gcflags &#39;-m -l&#39; main.go</code></p><h2 id="第二：反编译命令查看"><a href="#第二：反编译命令查看" class="headerlink" title="第二：反编译命令查看"></a>第二：反编译命令查看</h2><p><code>$ go tool compile -S main.go</code></p><p>注：可以通过 go tool compile -help 查看所有允许传递给编译器的标识参数</p><h3 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">ID     <span class="keyword">int64</span></span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">Avatar <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserInfo</span><span class="params">()</span> *<span class="title">User</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;User&#123;</span><br><span class="line">ID: <span class="number">666666</span>,</span><br><span class="line">Name: <span class="string">&quot;sim lou&quot;</span>,</span><br><span class="line">Avatar: <span class="string">&quot;https://www.baidu.com/avatar/666666&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">u := GetUserInfo()</span><br><span class="line"><span class="built_in">println</span>(u.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看编译器命令执行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$go</span> build -gcflags <span class="string">&#x27;-m -l&#x27;</span> escape_analysis.go </span><br><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">./escape_analysis.go:13:11: &amp;User literal escapes to heap</span><br></pre></td></tr></table></figure><p>通过查看分析结果，可得知 &amp;User 逃到了堆里，也就是分配到堆上了。这是不是有问题啊…再看看汇编代码确定一下，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$go</span> tool compile -S escape_analysis.go       </span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span>.GetUserInfo STEXT size=190 args=0x8 locals=0x18</span><br><span class="line">0x0000 00000 (escape_analysis.go:9)TEXT<span class="string">&quot;&quot;</span>.GetUserInfo(SB), ABIInternal, <span class="variable">$24</span>-8</span><br><span class="line">......</span><br><span class="line">0x002c 00044 (escape_analysis.go:13)CALLruntime.newobject(SB)</span><br><span class="line">......</span><br><span class="line">0x0045 00069 (escape_analysis.go:12)CMPLruntime.writeBarrier(SB), <span class="variable">$0</span></span><br><span class="line">0x004c 00076 (escape_analysis.go:12)JNE156</span><br><span class="line">0x004e 00078 (escape_analysis.go:12)LEAQgo.string.<span class="string">&quot;sim lou&quot;</span>(SB), CX</span><br><span class="line">......</span><br><span class="line">0x0061 00097 (escape_analysis.go:13)CMPLruntime.writeBarrier(SB), <span class="variable">$0</span></span><br><span class="line">0x0068 00104 (escape_analysis.go:13)JNE132</span><br><span class="line">0x006a 00106 (escape_analysis.go:13)LEAQgo.string.<span class="string">&quot;https://www.baidu.com/avatar/666666&quot;</span>(SB), CX</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>执行了 runtime.newobject 方法，也就是确实是分配到了堆上。这是为什么呢？这是因为 GetUserInfo() 返回的是指针对象，引用被返回到了方法之外了。因此编译器会把该对象分配到堆上，而不是栈上。否则方法结束之后，局部变量就被回收了，岂不是翻车。所以最终分配到堆上是理所当然的。</p><p>那么所有的指针都在堆上？也不是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintStr</span><span class="params">()</span></span>  &#123;</span><br><span class="line">str := <span class="built_in">new</span>(<span class="keyword">string</span>)</span><br><span class="line">*str = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">PrintStr()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看编译器逃逸分析的结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$go</span> build -gcflags <span class="string">&#x27;-m -l&#x27;</span> escape_analysis3.go             </span><br><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">./escape_analysis3.go:4:12: PrintStr new(string) does not escape</span><br></pre></td></tr></table></figure><p>看，该对象分配到栈上了。很核心的一点就是它有没有被作用域之外所引用，而这里作用域仍然保留在 main 中，因此它没有发生逃逸。</p><h3 id="不确定类型"><a href="#不确定类型" class="headerlink" title="不确定类型"></a>不确定类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">str := <span class="built_in">new</span>(<span class="keyword">string</span>)</span><br><span class="line">*str = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">fmt.Println(*str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令观察一下，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$go build -gcflags &#39;-m -l&#39; escape_analysis4.go</span><br><span class="line"># command-line-arguments</span><br><span class="line">.&#x2F;escape_analysis4.go:6:12: main new(string) does not escape</span><br><span class="line">.&#x2F;escape_analysis4.go:8:13: main ... argument does not escape</span><br><span class="line">.&#x2F;escape_analysis4.go:8:14: *str escapes to heap</span><br></pre></td></tr></table></figure><p>通过查看分析结果，可得知 str 变量逃到了堆上，也就是该对象在堆上分配。但上个案例时它还在栈上，我们也就 fmt 输出了它而已。这…到底发生了什么事？</p><p>相对案例一，案例二只加了一行代码 fmt.Println(str)，问题肯定出在它身上。其原型：<br><code>func Println(a ...interface&#123;&#125;) (n int, err error)</code></p><p>通过对其分析，可得知当形参为 interface 类型时，在编译阶段编译器无法确定其具体的类型。因此会产生逃逸，最终分配到堆上。</p><p>如果你有兴趣追源码的话，可以看下内部的 reflect.TypeOf(arg).Kind() 语句，其会造成堆逃逸，而表象就是 interface 类型会导致该对象分配到堆上。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>静态分配到栈上，性能一定比动态分配到堆上好</li><li>底层分配到堆，还是栈。实际上对你来说是透明的，不需要过度关心</li><li>每个 Go 版本的逃逸分析都会有所不同（会改变，会优化）</li><li>直接通过 go build -gcflags ‘-m -l’ 就可以看到逃逸分析的过程和结果</li><li>到处都用指针传递并不一定是最好的，要用对。</li></ul><p><a href="https://blog.csdn.net/u010853261/article/details/102846449#_34">golang 逃逸分析与栈、堆分配分析_惜暮-CSDN博客_golang 堆和栈</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们在写 golang 代码时候定义变量，那么一个很常见的问题，申请的变量保存在哪里呢？栈？还是堆？会不会有一些特殊例子？这篇文章我们就来探索下具体的case以及如何做分析。&lt;/p&gt;
&lt;p&gt;还是从实际使用场景出发：&lt;/p&gt;
&lt;h2 id=&quot;Question&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="开发" scheme="http://gonejack.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="golang" scheme="http://gonejack.github.io/tags/golang/"/>
    
    <category term="内存管理" scheme="http://gonejack.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>go垃圾回收</title>
    <link href="http://gonejack.github.io/2020/12/01/%E5%BC%80%E5%8F%91/go%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://gonejack.github.io/2020/12/01/%E5%BC%80%E5%8F%91/go%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2020-12-01T05:10:16.000Z</published>
    <updated>2020-12-01T05:11:48.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搞懂Go垃圾回收"><a href="#搞懂Go垃圾回收" class="headerlink" title="搞懂Go垃圾回收"></a>搞懂Go垃圾回收</h1><p>本文主要介绍了垃圾回收的概念，Golang GC的垃圾回收算法和工作原理，看完本文可以让你对Golang垃圾回收机制有个全面的理解。由于本人不了解其他语言的GC，并未对比其他语言的垃圾回收算法，需要的可以自行Google。</p><h2 id="什么是垃圾回收"><a href="#什么是垃圾回收" class="headerlink" title="什么是垃圾回收"></a>什么是垃圾回收</h2><p>垃圾回收（英语：Garbage Collection，缩写为GC），在计算机科学中是一种自动的存储器管理机制。当一个计算机上的动态存储器不再需要时，就应该予以释放，以让出存储器，这种存储器资源管理，称为垃圾回收。垃圾回收器可以让程序员减轻许多负担，也减少程序员犯错的机会。来自 <a href="https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_%28%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8%29">维基百科</a></p><p>简单地说， <strong>垃圾回收(GC)是在后台运行一个守护线程，它的作用是在监控各个对象的状态，识别并且丢弃不再使用的对象来释放和重用资源。</strong></p><h2 id="go的垃圾回收"><a href="#go的垃圾回收" class="headerlink" title="go的垃圾回收"></a>go的垃圾回收</h2><p>当前Golang使用的垃圾回收机制是 <strong>三色标记发</strong> 配合 <strong>写屏障</strong> 和 <strong>辅助GC</strong> ，三色标记法是 <strong>标记-清除法</strong> 的一种增强版本。</p><h3 id="标记清除法-mark-and-sweep"><a href="#标记清除法-mark-and-sweep" class="headerlink" title="标记清除法(mark and sweep)"></a>标记清除法(mark and sweep)</h3><p>原始的标记清楚法分为两个步骤：</p><ol><li>标记。先STP(Stop The World)，暂停整个程序的全部运行线程，将被引用的对象打上标记</li><li>清除没有被打标机的对象，即回收内存资源，然后恢复运行线程。</li></ol><p>这样做有个很大的问题就是要通过STW保证GC期间标记对象的状态不能变化，整个程序都要暂停掉，在外部看来程序就会卡顿。</p><h3 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h3><p>三色标记法是对标记阶段的改进，原理如下：</p><ol><li>初始状态所有对象都是白色。</li><li>从root根出发扫描所有根对象（下图a,b），将他们引用的对象标记为灰色（图中A，B）</li></ol><blockquote><p>那么什么是root呢？ 看了很多文章都没解释这这个概念，在这儿说明下：root区域主要是程序运行到当前时刻的栈和全局数据区域。  </p></blockquote><p><img src="assets/856B62B8-5E17-4E1D-A023-FCE9412A5924.png"></p><ol><li>分析灰色对象是否引用了其他对象。如果没有引用其它对象则将该灰色对象标记为黑色（上图中A）；如果有引用则将它变为黑色的同时将它引用的对象也变为灰色（上图中B引用了D）</li><li>重复步骤3，直到灰色对象队列为空。此时白色对象即为垃圾，进行回收。</li></ol><p>也可以参考下面的动图辅助理解：</p><p><img src="assets/16c9abaa4032c7ea.gif"></p><h2 id="Go-GC如何工作"><a href="#Go-GC如何工作" class="headerlink" title="Go GC如何工作"></a>Go GC如何工作</h2><p>上面介绍的是GO GC采用的三色标记算法，但是好像并没有体现出来怎么减少STW对程序的影响呢？其实是因为 <strong>Golang GC的大部分处理是和用户代码并行的</strong> 。</p><p>GC期间用户代码可能会改变某些对象的状态，如何实现GC和用户代码并行呢？先看下GC工作的完整流程：</p><ol><li><p>Mark:</p><ul><li>Mark Prepare: 初始化GC任务，包括开启写屏障(write barrier)和辅助GC(mutator assist)，统计root对象的任务数量等。 <strong>这个过程需要STW</strong></li><li>GC Drains: 扫描所有root对象，包括全局指针和goroutine(G)栈上的指针（扫描对应G栈时需停止该G)，将其加入标记队列(灰色队列)，并循环处理灰色队列的对象，直到灰色队列为空。 <strong>该过程后台并行执行</strong></li></ul></li><li><p>Mark Termination: 完成标记工作，重新扫描(re-scan)全局指针和栈。因为Mark和用户程序是并行的，所以在Mark过程中可能会有新的对象分配和指针赋值，这个时候就需要通过写屏障（write barrier）记录下来，re-scan 再检查一下。 <strong>这个过程也是会STW的。</strong></p></li><li><p>Sweep: 按照标记结果回收所有的白色对象， <strong>该过程后台并行执行</strong></p></li><li><p>Sweep Termination: 对未清扫的span进行清扫, 只有上一轮的GC的清扫工作完成才可以开始新一轮的GC。 如果标记期间用户逻辑改变了刚打完标记的对象的引用状态，怎么办呢？</p></li></ol><h2 id="写屏障-Write-Barrier"><a href="#写屏障-Write-Barrier" class="headerlink" title="写屏障(Write Barrier)"></a>写屏障(Write Barrier)</h2><p>写屏障：该屏障之前的写操作和之后的写操作相比，先被系统其它组件感知。 好难懂哦，结合上面GC工作的完整流程就好理解了，就是在每一轮GC开始时会初始化一个叫做“屏障”的东西，然后由它记录第一次scan时各个对象的状态，以便和第二次re-scan进行比对，引用状态变化的对象被标记为灰色以防止丢失，将屏障前后状态未变化对象继续处理。</p><h2 id="辅助GC"><a href="#辅助GC" class="headerlink" title="辅助GC"></a>辅助GC</h2><p>从上面的GC工作的完整流程可以看出Golang GC实际上把单次暂停时间分散掉了，本来程序执⾏可能是“⽤户代码–&gt;⼤段GC–&gt;⽤户代码”，那么分散以后实际上变成了“⽤户代码–&gt;⼩段 GC–&gt;⽤户代码–&gt;⼩段GC–&gt;⽤户代码”这样。如果GC回收的速度跟不上用户代码分配对象的速度呢？ Go 语⾔如果发现扫描后回收的速度跟不上分配的速度它依然会把⽤户逻辑暂停，⽤户逻辑暂停了以后也就意味着不会有新的对象出现，同时会把⽤户线程抢过来加⼊到垃圾回收⾥⾯加快垃圾回收的速度。这样⼀来原来的并发还是变成了STW，还是得把⽤户线程暂停掉，要不然扫描和回收没完没了了停不下来，因为新分配对象⽐回收快，所以这种东⻄叫做辅助回收。</p><h2 id="如何进行GC调优"><a href="#如何进行GC调优" class="headerlink" title="如何进行GC调优"></a>如何进行GC调优</h2><p>衡量GC对程序的影响可以参考这篇文章， <a href="https://www.oschina.net/translate/debugging-performance-issues-in-go-programs">Go 程序的性能调试问题</a> 。</p><p>减少对象的分配，合理重复利用； 避免string与[]byte转化；</p><blockquote><p>两者发生转换的时候，底层数据结结构会进行复制，因此导致 gc 效率会变低。  </p></blockquote><p>少量使用+连接 string；</p><blockquote><p>Go里面string是最基础的类型，是一个只读类型，针对他的每一个操作都会创建一个新的string。 如果是少量小文本拼接，用 “+” 就好；如果是大量小文本拼接，用 strings.Join；如果是大量大文本拼接，用 bytes.Buffer。  </p></blockquote><h2 id="GC触发条件"><a href="#GC触发条件" class="headerlink" title="GC触发条件"></a>GC触发条件</h2><p>自动垃圾回收的触发条件有两个：</p><ol><li>超过内存大小阈值</li><li>达到定时时间 阈值是由一个gcpercent的变量控制的,当新分配的内存占已在使用中的内存的比例超过gcprecent时就会触发。比如一次回收完毕后，内存的使用量为5M，那么下次回收的时机则是内存分配达到10M的时候。也就是说，并不是内存分配越多，垃圾回收频率越高。 如果一直达不到内存大小的阈值呢？这个时候GC就会被定时时间触发，比如一直达不到10M，那就定时（默认2min触发一次）触发一次GC保证资源的回收。</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>虽然Golang有自动垃圾回收机制，但是GC不是万能的，最好还是养成手动回收内存的习惯：比如手动把不再使用的内存释放，把对象置成nil，也可以考虑在合适的时候调用<code>runtime.GC()</code>触发GC。</p><p>参考：</p><p><a href="https://gocn.vip/question/265">string讨论</a></p><p><a href="https://www.jianshu.com/p/8b0c0f7772da">Go语言——垃圾回收GC</a></p><p><a href="https://mp.weixin.qq.com/s/Wh7A6czDIRofxveY_bEDNQ">Golang 垃圾回收剖析</a></p><p><a href="https://blog.csdn.net/u010649766/article/details/80582153">Golang垃圾回收机制详解</a></p><p><a href="https://lihaoquan.me/2016/11/3/go-gc-general.html">go垃圾回收概要</a></p><p><a href="https://wudaijun.com/2017/12/gc-study/">常见GC算法及Golang GC</a></p><p><a href="https://juejin.cn/post/6844903917650722829?utm_campaign=studygolang.com&utm_medium=studygolang.com&utm_medium=studygolang.com&utm_source=studygolang.com?utm_campaign=studygolang.com&utm_source=studygolang.com">搞懂Go垃圾回收</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;搞懂Go垃圾回收&quot;&gt;&lt;a href=&quot;#搞懂Go垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;搞懂Go垃圾回收&quot;&gt;&lt;/a&gt;搞懂Go垃圾回收&lt;/h1&gt;&lt;p&gt;本文主要介绍了垃圾回收的概念，Golang GC的垃圾回收算法和工作原理，看完本文可以让你对</summary>
      
    
    
    
    <category term="开发" scheme="http://gonejack.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="golang" scheme="http://gonejack.github.io/tags/golang/"/>
    
    <category term="内存管理" scheme="http://gonejack.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>go程序初始化顺序</title>
    <link href="http://gonejack.github.io/2020/12/01/%E5%BC%80%E5%8F%91/go%E7%A8%8B%E5%BA%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/"/>
    <id>http://gonejack.github.io/2020/12/01/%E5%BC%80%E5%8F%91/go%E7%A8%8B%E5%BA%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/</id>
    <published>2020-12-01T04:51:14.000Z</published>
    <updated>2020-12-01T04:58:19.193Z</updated>
    
    <content type="html"><![CDATA[<p>在一个 go 程序中通常包含：包、常量、变量、init()、main()等元素，如果同时存在多个包，包之间存在依赖关系，每个包中存在多个 init 函数，每个文件中存在多个 init 函数，那么问题来了，他们之间的执行顺序是什么样的？通过本文我们来对它们之间的执行顺序做尽可能详尽的说明。如有不正之处，欢迎批评指正。</p><h3 id="包的执行顺序"><a href="#包的执行顺序" class="headerlink" title="包的执行顺序"></a>包的执行顺序</h3><ul><li>在 main 包中的 go 文件默认总是会被执行</li><li>同包下的不同 go 文件，按照文件名“从小到大”排序顺序执行</li><li>其他的包只有被 main 包 import 才会执行，按照 import 的先后顺序执行</li><li>被递归 import 的包的初始化顺序与 import 顺序相反，例如：导入顺序 main –&gt; A –&gt; B –&gt; C，则初始化顺序为 C –&gt; B –&gt; A –&gt; main</li><li>一个包被其它多个包 import，但只能被初始化一次</li><li>main 包总是被最后一个初始化，因为它总是依赖别的包</li><li>避免出现循环 import，例如：A –&gt; B –&gt; C –&gt; A</li></ul><p>go 程序的初始化顺序见下图：</p><p><img src="assets/20170831112523944.jpeg"></p><h3 id="init-和-main-函数"><a href="#init-和-main-函数" class="headerlink" title="init 和 main 函数"></a>init 和 main 函数</h3><p>init()、main() 是 go 语言中的保留函数，两个函数在 go 语言中的区别如下：<br>相同点：</p><ul><li>两个函数在定义时不能有任何的参数和返回值</li><li>该函数只能由 go 程序自动调用，不可以被引用</li></ul><p>不同点：</p><ul><li>init 可以应用于任意包中，且可以重复定义多个。</li><li>main 函数只能用于 main 包中，且只能定义一个。</li></ul><p>两个函数的执行顺序：</p><ul><li>对同一个 go 文件的 init( ) 调用顺序是从上到下的</li><li>对同一个 package 中的不同文件，将文件名按字符串进行“从小到大”排序，之后顺序调用各文件中的init()函数</li><li>对于不同的 package，如果不相互依赖的话，按照 main 包中 import 的顺序调用其包中的 init() 函数</li><li>如果 package 存在依赖，调用顺序为最后被依赖的最先被初始化，例如：导入顺序 main –&gt; A –&gt; B –&gt; C，则初始化顺序为 C –&gt; B –&gt; A –&gt; main，一次执行对应的 init 方法。</li></ul><h3 id="常量、变量、init-、main"><a href="#常量、变量、init-、main" class="headerlink" title="常量、变量、init()、main()"></a>常量、变量、init()、main()</h3><p>在同一个文件中，常量、变量、init()、main() 依次进行初始化。</p><p><a href="https://blog.csdn.net/claram/article/details/77745665">go编程：浅析go程序初始化顺序</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在一个 go 程序中通常包含：包、常量、变量、init()、main()等元素，如果同时存在多个包，包之间存在依赖关系，每个包中存在多个 init 函数，每个文件中存在多个 init 函数，那么问题来了，他们之间的执行顺序是什么样的？通过本文我们来对它们之间的执行顺序做尽可</summary>
      
    
    
    
    <category term="开发" scheme="http://gonejack.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="golang" scheme="http://gonejack.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>解决git status不能显示中文</title>
    <link href="http://gonejack.github.io/2020/12/01/%E5%BC%80%E5%8F%91/git-show-chinese-filenames/"/>
    <id>http://gonejack.github.io/2020/12/01/%E5%BC%80%E5%8F%91/git-show-chinese-filenames/</id>
    <published>2020-12-01T04:39:34.000Z</published>
    <updated>2020-12-30T03:28:28.624Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>现象<br>status查看有改动但未提交的文件时总只显示数字串，显示不出中文文件名，非常不方便。如下图：<br><img src="assets/status-dig.jpg"></p></li><li><p>原因<br>在默认设置下，中文文件名在工作区状态输出，中文名不能正确显示，而是显示为八进制的字符编码。</p></li><li><p>解决办法<br>将 git 配置文件<code>core.quotepath</code>项设置为<code>false</code></p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config —global core.quotepath false</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;现象&lt;br&gt;status查看有改动但未提交的文件时总只显示数字串，显示不出中文文件名，非常不方便。如下图：&lt;br&gt;&lt;img src=&quot;assets/status-dig.jpg&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原因&lt;br&gt;在默认设置下，中文文件名在工</summary>
      
    
    
    
    <category term="技术" scheme="http://gonejack.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="git" scheme="http://gonejack.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Chrome 87 新功能：标签页分组，可自动分组同网站下标签页</title>
    <link href="http://gonejack.github.io/2020/12/01/%E5%B7%A5%E5%85%B7/chrome_87_%E6%96%B0%E5%8A%9F%E8%83%BD/"/>
    <id>http://gonejack.github.io/2020/12/01/%E5%B7%A5%E5%85%B7/chrome_87_%E6%96%B0%E5%8A%9F%E8%83%BD/</id>
    <published>2020-12-01T03:59:36.000Z</published>
    <updated>2020-12-01T04:13:26.116Z</updated>
    
    <content type="html"><![CDATA[<p>2020 年的最后一个版本 <a href="https://www.appinn.com/chrome-87-released/">Chrome 87</a> 新增了很多实用性的功能，在支持 <a href="https://www.appinn.com/chrome-87-search-tabs-in-addressbar/">地址栏切换标签页</a> 之后， <strong>标签页分组</strong> 功能页正式上线了，并且还可以为 <strong>同网站</strong> 自动创建标签页分组。@Appinn </p><p><img src="assets/image1.jpeg"></p><p>倒也不是吹捧，见过这么多分组扩展，青小蛙的确觉得 Chrome 官方的标签页分组方式更科学一些。</p><h2 id="标签页分组"><a href="#标签页分组" class="headerlink" title="标签页分组"></a>标签页分组</h2><p>升级至 Chrome 87 最新版本之后，就自动拥有了这个功能，只需要对着标签页右键，选择 <strong>向新群组中添加标签页</strong> ，即可创建分组： </p><p><img src="assets/image2.jpeg"></p><p>之后便可在其他标签页标题右键时，同样选择 <strong>向新群组中添加标签页</strong> 就能移动至分组中： </p><p><img src="assets/image3.jpeg"></p><p>之后，还可以对分组命名，并标记颜色，如果未命名，分组将以小圆点的方式表示，命名后就如下图，点击该名称还能折叠分组：</p><p><img src="assets/image4.jpeg"></p><h2 id="自动分组"><a href="#自动分组" class="headerlink" title="自动分组"></a>自动分组</h2><p>自动分组目前还属于实验性功能，需要在 Chrome://flags 中开启：</p><p><img src="assets/image5.jpeg"></p><p>开启后，新打开的标签页如果是同网站下，就会自动创建分组。</p><hr><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><ul><li><a href="https://www.appinn.com/lzzxt-game4/">3000时代来临，赢空间活动继续</a></li><li><a href="https://www.appinn.com/chrome-4-extensions-setup/">Chrome 4.0，用扩展武装它</a></li><li><a href="https://www.appinn.com/save-pinned-tabs-for-chrome/">Save Pinned Tabs – 保存 Chrome 当前固定标签页、分组、同步</a></li><li><a href="https://www.appinn.com/lzzxt-game3/">赢空间游戏新高 3432 分</a></li><li><a href="https://www.appinn.com/automatic-scrolling-tabs-for-chrome/">求一个脱离鼠标仍可网页自动向下滚动的 Chrome 插件</a></li></ul><hr><p><a href="http://www.appinn.com/copyright/?&amp;&amp;">©</a> 2019 青小蛙 for <a href="http://www.appinn.com/?&amp;&amp;">小众软件</a> | <a href="http://www.appinn.com/join-us/?&amp;&amp;">加入我们</a> | <a href="https://meta.appinn.com/c/faxian/?&amp;&amp;">投稿</a> | <a href="http://www.appinn.com/feeds-subscribe/?&amp;&amp;">订阅指南</a><br>3659b075e72a5b7b1b87ea74aa7932ff<br><a href="https://www.appinn.com/chrome-87-tabs-group/#comments">点击这里留言、和原作者一起评论</a> <a href="https://www.appinn.com/chrome-87-tabs-group/">https://www.appinn.com/chrome-87-tabs-group/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2020 年的最后一个版本 &lt;a href=&quot;https://www.appinn.com/chrome-87-released/&quot;&gt;Chrome 87&lt;/a&gt; 新增了很多实用性的功能，在支持 &lt;a href=&quot;https://www.appinn.com/chrome-8</summary>
      
    
    
    
    <category term="新闻记录" scheme="http://gonejack.github.io/categories/%E6%96%B0%E9%97%BB%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="chrome" scheme="http://gonejack.github.io/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://gonejack.github.io/2020/11/14/hello-world/"/>
    <id>http://gonejack.github.io/2020/11/14/hello-world/</id>
    <published>2020-11-14T20:37:58.507Z</published>
    <updated>2020-11-14T20:37:58.508Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
