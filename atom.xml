<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>0ccola.𐂂</title>
  
  <subtitle>零度可乐</subtitle>
  <link href="http://gonejack.github.io/atom.xml" rel="self"/>
  
  <link href="http://gonejack.github.io/"/>
  <updated>2020-12-01T05:11:48.389Z</updated>
  <id>http://gonejack.github.io/</id>
  
  <author>
    <name>John Youi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>go垃圾回收</title>
    <link href="http://gonejack.github.io/2020/12/01/%E6%8A%80%E6%9C%AF/go%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://gonejack.github.io/2020/12/01/%E6%8A%80%E6%9C%AF/go%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2020-12-01T05:10:16.000Z</published>
    <updated>2020-12-01T05:11:48.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搞懂Go垃圾回收"><a href="#搞懂Go垃圾回收" class="headerlink" title="搞懂Go垃圾回收"></a>搞懂Go垃圾回收</h1><p>本文主要介绍了垃圾回收的概念，Golang GC的垃圾回收算法和工作原理，看完本文可以让你对Golang垃圾回收机制有个全面的理解。由于本人不了解其他语言的GC，并未对比其他语言的垃圾回收算法，需要的可以自行Google。</p><h2 id="什么是垃圾回收"><a href="#什么是垃圾回收" class="headerlink" title="什么是垃圾回收"></a>什么是垃圾回收</h2><p>垃圾回收（英语：Garbage Collection，缩写为GC），在计算机科学中是一种自动的存储器管理机制。当一个计算机上的动态存储器不再需要时，就应该予以释放，以让出存储器，这种存储器资源管理，称为垃圾回收。垃圾回收器可以让程序员减轻许多负担，也减少程序员犯错的机会。来自 <a href="https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_%28%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8%29">维基百科</a></p><p>简单地说， <strong>垃圾回收(GC)是在后台运行一个守护线程，它的作用是在监控各个对象的状态，识别并且丢弃不再使用的对象来释放和重用资源。</strong></p><h2 id="go的垃圾回收"><a href="#go的垃圾回收" class="headerlink" title="go的垃圾回收"></a>go的垃圾回收</h2><p>当前Golang使用的垃圾回收机制是 <strong>三色标记发</strong> 配合 <strong>写屏障</strong> 和 <strong>辅助GC</strong> ，三色标记法是 <strong>标记-清除法</strong> 的一种增强版本。</p><h3 id="标记清除法-mark-and-sweep"><a href="#标记清除法-mark-and-sweep" class="headerlink" title="标记清除法(mark and sweep)"></a>标记清除法(mark and sweep)</h3><p>原始的标记清楚法分为两个步骤：</p><ol><li>标记。先STP(Stop The World)，暂停整个程序的全部运行线程，将被引用的对象打上标记</li><li>清除没有被打标机的对象，即回收内存资源，然后恢复运行线程。</li></ol><p>这样做有个很大的问题就是要通过STW保证GC期间标记对象的状态不能变化，整个程序都要暂停掉，在外部看来程序就会卡顿。</p><h3 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h3><p>三色标记法是对标记阶段的改进，原理如下：</p><ol><li>初始状态所有对象都是白色。</li><li>从root根出发扫描所有根对象（下图a,b），将他们引用的对象标记为灰色（图中A，B）</li></ol><blockquote><p>那么什么是root呢？ 看了很多文章都没解释这这个概念，在这儿说明下：root区域主要是程序运行到当前时刻的栈和全局数据区域。  </p></blockquote><p><img src="assets/856B62B8-5E17-4E1D-A023-FCE9412A5924.png"></p><ol><li>分析灰色对象是否引用了其他对象。如果没有引用其它对象则将该灰色对象标记为黑色（上图中A）；如果有引用则将它变为黑色的同时将它引用的对象也变为灰色（上图中B引用了D）</li><li>重复步骤3，直到灰色对象队列为空。此时白色对象即为垃圾，进行回收。</li></ol><p>也可以参考下面的动图辅助理解：</p><p><img src="assets/16c9abaa4032c7ea.gif"></p><h2 id="Go-GC如何工作"><a href="#Go-GC如何工作" class="headerlink" title="Go GC如何工作"></a>Go GC如何工作</h2><p>上面介绍的是GO GC采用的三色标记算法，但是好像并没有体现出来怎么减少STW对程序的影响呢？其实是因为 <strong>Golang GC的大部分处理是和用户代码并行的</strong> 。</p><p>GC期间用户代码可能会改变某些对象的状态，如何实现GC和用户代码并行呢？先看下GC工作的完整流程：</p><ol><li><p>Mark:</p><ul><li>Mark Prepare: 初始化GC任务，包括开启写屏障(write barrier)和辅助GC(mutator assist)，统计root对象的任务数量等。 <strong>这个过程需要STW</strong></li><li>GC Drains: 扫描所有root对象，包括全局指针和goroutine(G)栈上的指针（扫描对应G栈时需停止该G)，将其加入标记队列(灰色队列)，并循环处理灰色队列的对象，直到灰色队列为空。 <strong>该过程后台并行执行</strong></li></ul></li><li><p>Mark Termination: 完成标记工作，重新扫描(re-scan)全局指针和栈。因为Mark和用户程序是并行的，所以在Mark过程中可能会有新的对象分配和指针赋值，这个时候就需要通过写屏障（write barrier）记录下来，re-scan 再检查一下。 <strong>这个过程也是会STW的。</strong></p></li><li><p>Sweep: 按照标记结果回收所有的白色对象， <strong>该过程后台并行执行</strong></p></li><li><p>Sweep Termination: 对未清扫的span进行清扫, 只有上一轮的GC的清扫工作完成才可以开始新一轮的GC。 如果标记期间用户逻辑改变了刚打完标记的对象的引用状态，怎么办呢？</p></li></ol><h2 id="写屏障-Write-Barrier"><a href="#写屏障-Write-Barrier" class="headerlink" title="写屏障(Write Barrier)"></a>写屏障(Write Barrier)</h2><p>写屏障：该屏障之前的写操作和之后的写操作相比，先被系统其它组件感知。 好难懂哦，结合上面GC工作的完整流程就好理解了，就是在每一轮GC开始时会初始化一个叫做“屏障”的东西，然后由它记录第一次scan时各个对象的状态，以便和第二次re-scan进行比对，引用状态变化的对象被标记为灰色以防止丢失，将屏障前后状态未变化对象继续处理。</p><h2 id="辅助GC"><a href="#辅助GC" class="headerlink" title="辅助GC"></a>辅助GC</h2><p>从上面的GC工作的完整流程可以看出Golang GC实际上把单次暂停时间分散掉了，本来程序执⾏可能是“⽤户代码–&gt;⼤段GC–&gt;⽤户代码”，那么分散以后实际上变成了“⽤户代码–&gt;⼩段 GC–&gt;⽤户代码–&gt;⼩段GC–&gt;⽤户代码”这样。如果GC回收的速度跟不上用户代码分配对象的速度呢？ Go 语⾔如果发现扫描后回收的速度跟不上分配的速度它依然会把⽤户逻辑暂停，⽤户逻辑暂停了以后也就意味着不会有新的对象出现，同时会把⽤户线程抢过来加⼊到垃圾回收⾥⾯加快垃圾回收的速度。这样⼀来原来的并发还是变成了STW，还是得把⽤户线程暂停掉，要不然扫描和回收没完没了了停不下来，因为新分配对象⽐回收快，所以这种东⻄叫做辅助回收。</p><h2 id="如何进行GC调优"><a href="#如何进行GC调优" class="headerlink" title="如何进行GC调优"></a>如何进行GC调优</h2><p>衡量GC对程序的影响可以参考这篇文章， <a href="https://www.oschina.net/translate/debugging-performance-issues-in-go-programs">Go 程序的性能调试问题</a> 。</p><p>减少对象的分配，合理重复利用； 避免string与[]byte转化；</p><blockquote><p>两者发生转换的时候，底层数据结结构会进行复制，因此导致 gc 效率会变低。  </p></blockquote><p>少量使用+连接 string；</p><blockquote><p>Go里面string是最基础的类型，是一个只读类型，针对他的每一个操作都会创建一个新的string。 如果是少量小文本拼接，用 “+” 就好；如果是大量小文本拼接，用 strings.Join；如果是大量大文本拼接，用 bytes.Buffer。  </p></blockquote><h2 id="GC触发条件"><a href="#GC触发条件" class="headerlink" title="GC触发条件"></a>GC触发条件</h2><p>自动垃圾回收的触发条件有两个：</p><ol><li>超过内存大小阈值</li><li>达到定时时间 阈值是由一个gcpercent的变量控制的,当新分配的内存占已在使用中的内存的比例超过gcprecent时就会触发。比如一次回收完毕后，内存的使用量为5M，那么下次回收的时机则是内存分配达到10M的时候。也就是说，并不是内存分配越多，垃圾回收频率越高。 如果一直达不到内存大小的阈值呢？这个时候GC就会被定时时间触发，比如一直达不到10M，那就定时（默认2min触发一次）触发一次GC保证资源的回收。</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>虽然Golang有自动垃圾回收机制，但是GC不是万能的，最好还是养成手动回收内存的习惯：比如手动把不再使用的内存释放，把对象置成nil，也可以考虑在合适的时候调用<code>runtime.GC()</code>触发GC。</p><p>参考：</p><p><a href="https://gocn.vip/question/265">string讨论</a></p><p><a href="https://www.jianshu.com/p/8b0c0f7772da">Go语言——垃圾回收GC</a></p><p><a href="https://mp.weixin.qq.com/s/Wh7A6czDIRofxveY_bEDNQ">Golang 垃圾回收剖析</a></p><p><a href="https://blog.csdn.net/u010649766/article/details/80582153">Golang垃圾回收机制详解</a></p><p><a href="https://lihaoquan.me/2016/11/3/go-gc-general.html">go垃圾回收概要</a></p><p><a href="https://wudaijun.com/2017/12/gc-study/">常见GC算法及Golang GC</a></p><p><a href="https://juejin.cn/post/6844903917650722829?utm_campaign=studygolang.com&utm_medium=studygolang.com&utm_medium=studygolang.com&utm_source=studygolang.com?utm_campaign=studygolang.com&utm_source=studygolang.com">搞懂Go垃圾回收</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;搞懂Go垃圾回收&quot;&gt;&lt;a href=&quot;#搞懂Go垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;搞懂Go垃圾回收&quot;&gt;&lt;/a&gt;搞懂Go垃圾回收&lt;/h1&gt;&lt;p&gt;本文主要介绍了垃圾回收的概念，Golang GC的垃圾回收算法和工作原理，看完本文可以让你对</summary>
      
    
    
    
    <category term="开发" scheme="http://gonejack.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="golang" scheme="http://gonejack.github.io/tags/golang/"/>
    
    <category term="内存管理" scheme="http://gonejack.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>go程序初始化顺序</title>
    <link href="http://gonejack.github.io/2020/12/01/%E6%8A%80%E6%9C%AF/go%E7%A8%8B%E5%BA%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/"/>
    <id>http://gonejack.github.io/2020/12/01/%E6%8A%80%E6%9C%AF/go%E7%A8%8B%E5%BA%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/</id>
    <published>2020-12-01T04:51:14.000Z</published>
    <updated>2020-12-01T04:58:19.193Z</updated>
    
    <content type="html"><![CDATA[<p>在一个 go 程序中通常包含：包、常量、变量、init()、main()等元素，如果同时存在多个包，包之间存在依赖关系，每个包中存在多个 init 函数，每个文件中存在多个 init 函数，那么问题来了，他们之间的执行顺序是什么样的？通过本文我们来对它们之间的执行顺序做尽可能详尽的说明。如有不正之处，欢迎批评指正。</p><h3 id="包的执行顺序"><a href="#包的执行顺序" class="headerlink" title="包的执行顺序"></a>包的执行顺序</h3><ul><li>在 main 包中的 go 文件默认总是会被执行</li><li>同包下的不同 go 文件，按照文件名“从小到大”排序顺序执行</li><li>其他的包只有被 main 包 import 才会执行，按照 import 的先后顺序执行</li><li>被递归 import 的包的初始化顺序与 import 顺序相反，例如：导入顺序 main –&gt; A –&gt; B –&gt; C，则初始化顺序为 C –&gt; B –&gt; A –&gt; main</li><li>一个包被其它多个包 import，但只能被初始化一次</li><li>main 包总是被最后一个初始化，因为它总是依赖别的包</li><li>避免出现循环 import，例如：A –&gt; B –&gt; C –&gt; A</li></ul><p>go 程序的初始化顺序见下图：</p><p><img src="assets/20170831112523944.jpeg"></p><h3 id="init-和-main-函数"><a href="#init-和-main-函数" class="headerlink" title="init 和 main 函数"></a>init 和 main 函数</h3><p>init()、main() 是 go 语言中的保留函数，两个函数在 go 语言中的区别如下：<br>相同点：</p><ul><li>两个函数在定义时不能有任何的参数和返回值</li><li>该函数只能由 go 程序自动调用，不可以被引用</li></ul><p>不同点：</p><ul><li>init 可以应用于任意包中，且可以重复定义多个。</li><li>main 函数只能用于 main 包中，且只能定义一个。</li></ul><p>两个函数的执行顺序：</p><ul><li>对同一个 go 文件的 init( ) 调用顺序是从上到下的</li><li>对同一个 package 中的不同文件，将文件名按字符串进行“从小到大”排序，之后顺序调用各文件中的init()函数</li><li>对于不同的 package，如果不相互依赖的话，按照 main 包中 import 的顺序调用其包中的 init() 函数</li><li>如果 package 存在依赖，调用顺序为最后被依赖的最先被初始化，例如：导入顺序 main –&gt; A –&gt; B –&gt; C，则初始化顺序为 C –&gt; B –&gt; A –&gt; main，一次执行对应的 init 方法。</li></ul><h3 id="常量、变量、init-、main"><a href="#常量、变量、init-、main" class="headerlink" title="常量、变量、init()、main()"></a>常量、变量、init()、main()</h3><p>在同一个文件中，常量、变量、init()、main() 依次进行初始化。</p><p><a href="https://blog.csdn.net/claram/article/details/77745665">go编程：浅析go程序初始化顺序</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在一个 go 程序中通常包含：包、常量、变量、init()、main()等元素，如果同时存在多个包，包之间存在依赖关系，每个包中存在多个 init 函数，每个文件中存在多个 init 函数，那么问题来了，他们之间的执行顺序是什么样的？通过本文我们来对它们之间的执行顺序做尽可</summary>
      
    
    
    
    <category term="开发" scheme="http://gonejack.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="golang" scheme="http://gonejack.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>解决git status不能显示中文</title>
    <link href="http://gonejack.github.io/2020/12/01/%E6%8A%80%E6%9C%AF/git-show-chinese-filenames/"/>
    <id>http://gonejack.github.io/2020/12/01/%E6%8A%80%E6%9C%AF/git-show-chinese-filenames/</id>
    <published>2020-12-01T04:39:34.000Z</published>
    <updated>2020-12-01T04:45:30.015Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>现象<br>status查看有改动但未提交的文件时总只显示数字串，显示不出中文文件名，非常不方便。如下图：<br><img src="assets/status-dig.jpg"></p></li><li><p>原因<br>在默认设置下，中文文件名在工作区状态输出，中文名不能正确显示，而是显示为八进制的字符编码。</p></li><li><p>解决办法<br>将git 配置文件 core.quotepath项设置为false</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config —global core.quotepath false</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;现象&lt;br&gt;status查看有改动但未提交的文件时总只显示数字串，显示不出中文文件名，非常不方便。如下图：&lt;br&gt;&lt;img src=&quot;assets/status-dig.jpg&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原因&lt;br&gt;在默认设置下，中文文件名在工</summary>
      
    
    
    
    <category term="技术" scheme="http://gonejack.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="git" scheme="http://gonejack.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Chrome 87 新功能：标签页分组，可自动分组同网站下标签页</title>
    <link href="http://gonejack.github.io/2020/12/01/%E5%B7%A5%E5%85%B7/chrome_87_%E6%96%B0%E5%8A%9F%E8%83%BD/"/>
    <id>http://gonejack.github.io/2020/12/01/%E5%B7%A5%E5%85%B7/chrome_87_%E6%96%B0%E5%8A%9F%E8%83%BD/</id>
    <published>2020-12-01T03:59:36.000Z</published>
    <updated>2020-12-01T04:13:26.116Z</updated>
    
    <content type="html"><![CDATA[<p>2020 年的最后一个版本 <a href="https://www.appinn.com/chrome-87-released/">Chrome 87</a> 新增了很多实用性的功能，在支持 <a href="https://www.appinn.com/chrome-87-search-tabs-in-addressbar/">地址栏切换标签页</a> 之后， <strong>标签页分组</strong> 功能页正式上线了，并且还可以为 <strong>同网站</strong> 自动创建标签页分组。@Appinn </p><p><img src="assets/image1.jpeg"></p><p>倒也不是吹捧，见过这么多分组扩展，青小蛙的确觉得 Chrome 官方的标签页分组方式更科学一些。</p><h2 id="标签页分组"><a href="#标签页分组" class="headerlink" title="标签页分组"></a>标签页分组</h2><p>升级至 Chrome 87 最新版本之后，就自动拥有了这个功能，只需要对着标签页右键，选择 <strong>向新群组中添加标签页</strong> ，即可创建分组： </p><p><img src="assets/image2.jpeg"></p><p>之后便可在其他标签页标题右键时，同样选择 <strong>向新群组中添加标签页</strong> 就能移动至分组中： </p><p><img src="assets/image3.jpeg"></p><p>之后，还可以对分组命名，并标记颜色，如果未命名，分组将以小圆点的方式表示，命名后就如下图，点击该名称还能折叠分组：</p><p><img src="assets/image4.jpeg"></p><h2 id="自动分组"><a href="#自动分组" class="headerlink" title="自动分组"></a>自动分组</h2><p>自动分组目前还属于实验性功能，需要在 Chrome://flags 中开启：</p><p><img src="assets/image5.jpeg"></p><p>开启后，新打开的标签页如果是同网站下，就会自动创建分组。</p><hr><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><ul><li><a href="https://www.appinn.com/lzzxt-game4/">3000时代来临，赢空间活动继续</a></li><li><a href="https://www.appinn.com/chrome-4-extensions-setup/">Chrome 4.0，用扩展武装它</a></li><li><a href="https://www.appinn.com/save-pinned-tabs-for-chrome/">Save Pinned Tabs – 保存 Chrome 当前固定标签页、分组、同步</a></li><li><a href="https://www.appinn.com/lzzxt-game3/">赢空间游戏新高 3432 分</a></li><li><a href="https://www.appinn.com/automatic-scrolling-tabs-for-chrome/">求一个脱离鼠标仍可网页自动向下滚动的 Chrome 插件</a></li></ul><hr><p><a href="http://www.appinn.com/copyright/?&amp;&amp;">©</a> 2019 青小蛙 for <a href="http://www.appinn.com/?&amp;&amp;">小众软件</a> | <a href="http://www.appinn.com/join-us/?&amp;&amp;">加入我们</a> | <a href="https://meta.appinn.com/c/faxian/?&amp;&amp;">投稿</a> | <a href="http://www.appinn.com/feeds-subscribe/?&amp;&amp;">订阅指南</a><br>3659b075e72a5b7b1b87ea74aa7932ff<br><a href="https://www.appinn.com/chrome-87-tabs-group/#comments">点击这里留言、和原作者一起评论</a> <a href="https://www.appinn.com/chrome-87-tabs-group/">https://www.appinn.com/chrome-87-tabs-group/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2020 年的最后一个版本 &lt;a href=&quot;https://www.appinn.com/chrome-87-released/&quot;&gt;Chrome 87&lt;/a&gt; 新增了很多实用性的功能，在支持 &lt;a href=&quot;https://www.appinn.com/chrome-8</summary>
      
    
    
    
    <category term="新闻记录" scheme="http://gonejack.github.io/categories/%E6%96%B0%E9%97%BB%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="chrome" scheme="http://gonejack.github.io/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://gonejack.github.io/2020/11/14/hello-world/"/>
    <id>http://gonejack.github.io/2020/11/14/hello-world/</id>
    <published>2020-11-14T20:37:58.507Z</published>
    <updated>2020-11-14T20:37:58.508Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
