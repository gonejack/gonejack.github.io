<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>0ccola.𐂂</title>
  
  <subtitle>零度可乐</subtitle>
  <link href="http://gonejack.github.io/atom.xml" rel="self"/>
  
  <link href="http://gonejack.github.io/"/>
  <updated>2020-12-01T05:20:00.784Z</updated>
  <id>http://gonejack.github.io/</id>
  
  <author>
    <name>John Youi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>go逃逸分析与栈、堆分配分析</title>
    <link href="http://gonejack.github.io/2020/12/01/%E6%8A%80%E6%9C%AF/go%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E4%B8%8E%E6%A0%88%E3%80%81%E5%A0%86%E5%88%86%E9%85%8D%E5%88%86%E6%9E%90/"/>
    <id>http://gonejack.github.io/2020/12/01/%E6%8A%80%E6%9C%AF/go%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E4%B8%8E%E6%A0%88%E3%80%81%E5%A0%86%E5%88%86%E9%85%8D%E5%88%86%E6%9E%90/</id>
    <published>2020-12-01T05:19:18.000Z</published>
    <updated>2020-12-01T05:20:00.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="golang-逃逸分析与栈、堆分配分析"><a href="#golang-逃逸分析与栈、堆分配分析" class="headerlink" title="golang 逃逸分析与栈、堆分配分析"></a>golang 逃逸分析与栈、堆分配分析</h1><p>我们在写 golang 代码时候定义变量，那么一个很常见的问题，申请的变量保存在哪里呢？栈？还是堆？会不会有一些特殊例子？这篇文章我们就来探索下具体的case以及如何做分析。</p><p>还是从实际使用场景出发：</p><h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">ID     <span class="keyword">int64</span></span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">Avatar <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserInfo</span><span class="params">()</span> *<span class="title">User</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;User&#123;</span><br><span class="line">ID: <span class="number">666666</span>,</span><br><span class="line">Name: <span class="string">&quot;sim lou&quot;</span>,</span><br><span class="line">Avatar: <span class="string">&quot;https://www.baidu.com/avatar/666666&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">u := GetUserInfo()</span><br><span class="line"><span class="built_in">println</span>(u.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里GetUserInfo 函数里面的 User 对象是存储在函数栈上还是堆上？</p><h2 id="什么是堆？什么是栈？"><a href="#什么是堆？什么是栈？" class="headerlink" title="什么是堆？什么是栈？"></a>什么是堆？什么是栈？</h2><p>简单说：</p><ul><li>堆：一般来讲是人为手动进行管理，手动申请、分配、释放。一般所涉及的内存大小并不定，一般会存放较大的对象。另外其分配相对慢，涉及到的指令动作也相对多</li><li>栈：由编译器进行管理，自动申请、分配、释放。一般不会太大，我们常见的函数参数（不同平台允许存放的数量不同），局部变量等等都会存放在栈上</li></ul><p>今天我们介绍的 Go 语言，它的堆栈分配是通过 Compiler 进行分析，GC 去管理的，而对其的分析选择动作就是今天探讨的重点</p><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>逃逸分析是一种确定指针动态范围的方法，简单来说就是分析在程序的哪些地方可以访问到该指针。</p><p>通俗地讲，逃逸分析就是确定一个变量要放堆上还是栈上，规则如下：</p><ul><li>是否有在其他地方（非局部）被引用。只要有可能被引用了，那么它一定分配到堆上。否则分配到栈上</li><li>即使没有被外部引用，但对象过大，无法存放在栈区上。依然有可能分配到堆上</li></ul><p>对此你可以理解为，逃逸分析是编译器用于决定变量分配到堆上还是栈上的一种行为。</p><h2 id="在什么阶段确立逃逸"><a href="#在什么阶段确立逃逸" class="headerlink" title="在什么阶段确立逃逸"></a>在什么阶段确立逃逸</h2><p>go 在编译阶段确立逃逸，注意并不是在运行时</p><h2 id="为什么需要逃逸"><a href="#为什么需要逃逸" class="headerlink" title="为什么需要逃逸"></a>为什么需要逃逸</h2><p>其实就是为了尽可能在栈上分配内存，我们可以反过来想，如果变量都分配到堆上了会出现什么事情？例如：</p><ul><li>垃圾回收（GC）的压力不断增大</li><li>申请、分配、回收内存的系统开销增大（相对于栈）</li><li>动态分配产生一定量的内存碎片</li></ul><p>其实总的来说，就是频繁申请、分配堆内存是有一定 “代价” 的。会影响应用程序运行的效率，间接影响到整体系统。因此 “按需分配” 最大限度的灵活利用资源，才是正确的治理之道。这就是为什么需要逃逸分析的原因，你觉得呢？</p><h2 id="go怎么确定是否逃逸"><a href="#go怎么确定是否逃逸" class="headerlink" title="go怎么确定是否逃逸"></a>go怎么确定是否逃逸</h2><p>可以看到详细的逃逸分析过程。而指令集 -gcflags 用于将标识参数传递给 Go 编译器，涉及如下：</p><ul><li>-m 会打印出逃逸分析的优化策略，实际上最多总共可以用 4 个 -m，但是信息量较大，一般用 1 个就可以了</li><li>-l 会禁用函数内联，在这里禁用掉 inline 能更好的观察逃逸情况，减少干扰</li></ul><p><code>$ go build -gcflags &#39;-m -l&#39; main.go</code></p><h2 id="第二：反编译命令查看"><a href="#第二：反编译命令查看" class="headerlink" title="第二：反编译命令查看"></a>第二：反编译命令查看</h2><p><code>$ go tool compile -S main.go</code></p><p>注：可以通过 go tool compile -help 查看所有允许传递给编译器的标识参数</p><h3 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">ID     <span class="keyword">int64</span></span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">Avatar <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserInfo</span><span class="params">()</span> *<span class="title">User</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;User&#123;</span><br><span class="line">ID: <span class="number">666666</span>,</span><br><span class="line">Name: <span class="string">&quot;sim lou&quot;</span>,</span><br><span class="line">Avatar: <span class="string">&quot;https://www.baidu.com/avatar/666666&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">u := GetUserInfo()</span><br><span class="line"><span class="built_in">println</span>(u.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看编译器命令执行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$go</span> build -gcflags <span class="string">&#x27;-m -l&#x27;</span> escape_analysis.go </span><br><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">./escape_analysis.go:13:11: &amp;User literal escapes to heap</span><br></pre></td></tr></table></figure><p>通过查看分析结果，可得知 &amp;User 逃到了堆里，也就是分配到堆上了。这是不是有问题啊…再看看汇编代码确定一下，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$go</span> tool compile -S escape_analysis.go       </span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span>.GetUserInfo STEXT size=190 args=0x8 locals=0x18</span><br><span class="line">0x0000 00000 (escape_analysis.go:9)TEXT<span class="string">&quot;&quot;</span>.GetUserInfo(SB), ABIInternal, <span class="variable">$24</span>-8</span><br><span class="line">......</span><br><span class="line">0x002c 00044 (escape_analysis.go:13)CALLruntime.newobject(SB)</span><br><span class="line">......</span><br><span class="line">0x0045 00069 (escape_analysis.go:12)CMPLruntime.writeBarrier(SB), <span class="variable">$0</span></span><br><span class="line">0x004c 00076 (escape_analysis.go:12)JNE156</span><br><span class="line">0x004e 00078 (escape_analysis.go:12)LEAQgo.string.<span class="string">&quot;sim lou&quot;</span>(SB), CX</span><br><span class="line">......</span><br><span class="line">0x0061 00097 (escape_analysis.go:13)CMPLruntime.writeBarrier(SB), <span class="variable">$0</span></span><br><span class="line">0x0068 00104 (escape_analysis.go:13)JNE132</span><br><span class="line">0x006a 00106 (escape_analysis.go:13)LEAQgo.string.<span class="string">&quot;https://www.baidu.com/avatar/666666&quot;</span>(SB), CX</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>执行了 runtime.newobject 方法，也就是确实是分配到了堆上。这是为什么呢？这是因为 GetUserInfo() 返回的是指针对象，引用被返回到了方法之外了。因此编译器会把该对象分配到堆上，而不是栈上。否则方法结束之后，局部变量就被回收了，岂不是翻车。所以最终分配到堆上是理所当然的。</p><p>那么所有的指针都在堆上？也不是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintStr</span><span class="params">()</span></span>  &#123;</span><br><span class="line">str := <span class="built_in">new</span>(<span class="keyword">string</span>)</span><br><span class="line">*str = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">PrintStr()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看编译器逃逸分析的结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$go</span> build -gcflags <span class="string">&#x27;-m -l&#x27;</span> escape_analysis3.go             </span><br><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">./escape_analysis3.go:4:12: PrintStr new(string) does not escape</span><br></pre></td></tr></table></figure><p>看，该对象分配到栈上了。很核心的一点就是它有没有被作用域之外所引用，而这里作用域仍然保留在 main 中，因此它没有发生逃逸。</p><h3 id="不确定类型"><a href="#不确定类型" class="headerlink" title="不确定类型"></a>不确定类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">str := <span class="built_in">new</span>(<span class="keyword">string</span>)</span><br><span class="line">*str = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">fmt.Println(*str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令观察一下，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$go build -gcflags &#39;-m -l&#39; escape_analysis4.go</span><br><span class="line"># command-line-arguments</span><br><span class="line">.&#x2F;escape_analysis4.go:6:12: main new(string) does not escape</span><br><span class="line">.&#x2F;escape_analysis4.go:8:13: main ... argument does not escape</span><br><span class="line">.&#x2F;escape_analysis4.go:8:14: *str escapes to heap</span><br></pre></td></tr></table></figure><p>通过查看分析结果，可得知 str 变量逃到了堆上，也就是该对象在堆上分配。但上个案例时它还在栈上，我们也就 fmt 输出了它而已。这…到底发生了什么事？</p><p>相对案例一，案例二只加了一行代码 fmt.Println(str)，问题肯定出在它身上。其原型：<br><code>func Println(a ...interface&#123;&#125;) (n int, err error)</code></p><p>通过对其分析，可得知当形参为 interface 类型时，在编译阶段编译器无法确定其具体的类型。因此会产生逃逸，最终分配到堆上。</p><p>如果你有兴趣追源码的话，可以看下内部的 reflect.TypeOf(arg).Kind() 语句，其会造成堆逃逸，而表象就是 interface 类型会导致该对象分配到堆上。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>静态分配到栈上，性能一定比动态分配到堆上好</li><li>底层分配到堆，还是栈。实际上对你来说是透明的，不需要过度关心</li><li>每个 Go 版本的逃逸分析都会有所不同（会改变，会优化）</li><li>直接通过 go build -gcflags ‘-m -l’ 就可以看到逃逸分析的过程和结果</li><li>到处都用指针传递并不一定是最好的，要用对。</li></ul><p><a href="https://blog.csdn.net/u010853261/article/details/102846449#_34">golang 逃逸分析与栈、堆分配分析_惜暮-CSDN博客_golang 堆和栈</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;golang-逃逸分析与栈、堆分配分析&quot;&gt;&lt;a href=&quot;#golang-逃逸分析与栈、堆分配分析&quot; class=&quot;headerlink&quot; title=&quot;golang 逃逸分析与栈、堆分配分析&quot;&gt;&lt;/a&gt;golang 逃逸分析与栈、堆分配分析&lt;/h1&gt;&lt;p&gt;我们</summary>
      
    
    
    
    <category term="开发" scheme="http://gonejack.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="golang" scheme="http://gonejack.github.io/tags/golang/"/>
    
    <category term="内存管理" scheme="http://gonejack.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>go垃圾回收</title>
    <link href="http://gonejack.github.io/2020/12/01/%E6%8A%80%E6%9C%AF/go%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://gonejack.github.io/2020/12/01/%E6%8A%80%E6%9C%AF/go%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2020-12-01T05:10:16.000Z</published>
    <updated>2020-12-01T05:11:48.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搞懂Go垃圾回收"><a href="#搞懂Go垃圾回收" class="headerlink" title="搞懂Go垃圾回收"></a>搞懂Go垃圾回收</h1><p>本文主要介绍了垃圾回收的概念，Golang GC的垃圾回收算法和工作原理，看完本文可以让你对Golang垃圾回收机制有个全面的理解。由于本人不了解其他语言的GC，并未对比其他语言的垃圾回收算法，需要的可以自行Google。</p><h2 id="什么是垃圾回收"><a href="#什么是垃圾回收" class="headerlink" title="什么是垃圾回收"></a>什么是垃圾回收</h2><p>垃圾回收（英语：Garbage Collection，缩写为GC），在计算机科学中是一种自动的存储器管理机制。当一个计算机上的动态存储器不再需要时，就应该予以释放，以让出存储器，这种存储器资源管理，称为垃圾回收。垃圾回收器可以让程序员减轻许多负担，也减少程序员犯错的机会。来自 <a href="https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_%28%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8%29">维基百科</a></p><p>简单地说， <strong>垃圾回收(GC)是在后台运行一个守护线程，它的作用是在监控各个对象的状态，识别并且丢弃不再使用的对象来释放和重用资源。</strong></p><h2 id="go的垃圾回收"><a href="#go的垃圾回收" class="headerlink" title="go的垃圾回收"></a>go的垃圾回收</h2><p>当前Golang使用的垃圾回收机制是 <strong>三色标记发</strong> 配合 <strong>写屏障</strong> 和 <strong>辅助GC</strong> ，三色标记法是 <strong>标记-清除法</strong> 的一种增强版本。</p><h3 id="标记清除法-mark-and-sweep"><a href="#标记清除法-mark-and-sweep" class="headerlink" title="标记清除法(mark and sweep)"></a>标记清除法(mark and sweep)</h3><p>原始的标记清楚法分为两个步骤：</p><ol><li>标记。先STP(Stop The World)，暂停整个程序的全部运行线程，将被引用的对象打上标记</li><li>清除没有被打标机的对象，即回收内存资源，然后恢复运行线程。</li></ol><p>这样做有个很大的问题就是要通过STW保证GC期间标记对象的状态不能变化，整个程序都要暂停掉，在外部看来程序就会卡顿。</p><h3 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h3><p>三色标记法是对标记阶段的改进，原理如下：</p><ol><li>初始状态所有对象都是白色。</li><li>从root根出发扫描所有根对象（下图a,b），将他们引用的对象标记为灰色（图中A，B）</li></ol><blockquote><p>那么什么是root呢？ 看了很多文章都没解释这这个概念，在这儿说明下：root区域主要是程序运行到当前时刻的栈和全局数据区域。  </p></blockquote><p><img src="assets/856B62B8-5E17-4E1D-A023-FCE9412A5924.png"></p><ol><li>分析灰色对象是否引用了其他对象。如果没有引用其它对象则将该灰色对象标记为黑色（上图中A）；如果有引用则将它变为黑色的同时将它引用的对象也变为灰色（上图中B引用了D）</li><li>重复步骤3，直到灰色对象队列为空。此时白色对象即为垃圾，进行回收。</li></ol><p>也可以参考下面的动图辅助理解：</p><p><img src="assets/16c9abaa4032c7ea.gif"></p><h2 id="Go-GC如何工作"><a href="#Go-GC如何工作" class="headerlink" title="Go GC如何工作"></a>Go GC如何工作</h2><p>上面介绍的是GO GC采用的三色标记算法，但是好像并没有体现出来怎么减少STW对程序的影响呢？其实是因为 <strong>Golang GC的大部分处理是和用户代码并行的</strong> 。</p><p>GC期间用户代码可能会改变某些对象的状态，如何实现GC和用户代码并行呢？先看下GC工作的完整流程：</p><ol><li><p>Mark:</p><ul><li>Mark Prepare: 初始化GC任务，包括开启写屏障(write barrier)和辅助GC(mutator assist)，统计root对象的任务数量等。 <strong>这个过程需要STW</strong></li><li>GC Drains: 扫描所有root对象，包括全局指针和goroutine(G)栈上的指针（扫描对应G栈时需停止该G)，将其加入标记队列(灰色队列)，并循环处理灰色队列的对象，直到灰色队列为空。 <strong>该过程后台并行执行</strong></li></ul></li><li><p>Mark Termination: 完成标记工作，重新扫描(re-scan)全局指针和栈。因为Mark和用户程序是并行的，所以在Mark过程中可能会有新的对象分配和指针赋值，这个时候就需要通过写屏障（write barrier）记录下来，re-scan 再检查一下。 <strong>这个过程也是会STW的。</strong></p></li><li><p>Sweep: 按照标记结果回收所有的白色对象， <strong>该过程后台并行执行</strong></p></li><li><p>Sweep Termination: 对未清扫的span进行清扫, 只有上一轮的GC的清扫工作完成才可以开始新一轮的GC。 如果标记期间用户逻辑改变了刚打完标记的对象的引用状态，怎么办呢？</p></li></ol><h2 id="写屏障-Write-Barrier"><a href="#写屏障-Write-Barrier" class="headerlink" title="写屏障(Write Barrier)"></a>写屏障(Write Barrier)</h2><p>写屏障：该屏障之前的写操作和之后的写操作相比，先被系统其它组件感知。 好难懂哦，结合上面GC工作的完整流程就好理解了，就是在每一轮GC开始时会初始化一个叫做“屏障”的东西，然后由它记录第一次scan时各个对象的状态，以便和第二次re-scan进行比对，引用状态变化的对象被标记为灰色以防止丢失，将屏障前后状态未变化对象继续处理。</p><h2 id="辅助GC"><a href="#辅助GC" class="headerlink" title="辅助GC"></a>辅助GC</h2><p>从上面的GC工作的完整流程可以看出Golang GC实际上把单次暂停时间分散掉了，本来程序执⾏可能是“⽤户代码–&gt;⼤段GC–&gt;⽤户代码”，那么分散以后实际上变成了“⽤户代码–&gt;⼩段 GC–&gt;⽤户代码–&gt;⼩段GC–&gt;⽤户代码”这样。如果GC回收的速度跟不上用户代码分配对象的速度呢？ Go 语⾔如果发现扫描后回收的速度跟不上分配的速度它依然会把⽤户逻辑暂停，⽤户逻辑暂停了以后也就意味着不会有新的对象出现，同时会把⽤户线程抢过来加⼊到垃圾回收⾥⾯加快垃圾回收的速度。这样⼀来原来的并发还是变成了STW，还是得把⽤户线程暂停掉，要不然扫描和回收没完没了了停不下来，因为新分配对象⽐回收快，所以这种东⻄叫做辅助回收。</p><h2 id="如何进行GC调优"><a href="#如何进行GC调优" class="headerlink" title="如何进行GC调优"></a>如何进行GC调优</h2><p>衡量GC对程序的影响可以参考这篇文章， <a href="https://www.oschina.net/translate/debugging-performance-issues-in-go-programs">Go 程序的性能调试问题</a> 。</p><p>减少对象的分配，合理重复利用； 避免string与[]byte转化；</p><blockquote><p>两者发生转换的时候，底层数据结结构会进行复制，因此导致 gc 效率会变低。  </p></blockquote><p>少量使用+连接 string；</p><blockquote><p>Go里面string是最基础的类型，是一个只读类型，针对他的每一个操作都会创建一个新的string。 如果是少量小文本拼接，用 “+” 就好；如果是大量小文本拼接，用 strings.Join；如果是大量大文本拼接，用 bytes.Buffer。  </p></blockquote><h2 id="GC触发条件"><a href="#GC触发条件" class="headerlink" title="GC触发条件"></a>GC触发条件</h2><p>自动垃圾回收的触发条件有两个：</p><ol><li>超过内存大小阈值</li><li>达到定时时间 阈值是由一个gcpercent的变量控制的,当新分配的内存占已在使用中的内存的比例超过gcprecent时就会触发。比如一次回收完毕后，内存的使用量为5M，那么下次回收的时机则是内存分配达到10M的时候。也就是说，并不是内存分配越多，垃圾回收频率越高。 如果一直达不到内存大小的阈值呢？这个时候GC就会被定时时间触发，比如一直达不到10M，那就定时（默认2min触发一次）触发一次GC保证资源的回收。</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>虽然Golang有自动垃圾回收机制，但是GC不是万能的，最好还是养成手动回收内存的习惯：比如手动把不再使用的内存释放，把对象置成nil，也可以考虑在合适的时候调用<code>runtime.GC()</code>触发GC。</p><p>参考：</p><p><a href="https://gocn.vip/question/265">string讨论</a></p><p><a href="https://www.jianshu.com/p/8b0c0f7772da">Go语言——垃圾回收GC</a></p><p><a href="https://mp.weixin.qq.com/s/Wh7A6czDIRofxveY_bEDNQ">Golang 垃圾回收剖析</a></p><p><a href="https://blog.csdn.net/u010649766/article/details/80582153">Golang垃圾回收机制详解</a></p><p><a href="https://lihaoquan.me/2016/11/3/go-gc-general.html">go垃圾回收概要</a></p><p><a href="https://wudaijun.com/2017/12/gc-study/">常见GC算法及Golang GC</a></p><p><a href="https://juejin.cn/post/6844903917650722829?utm_campaign=studygolang.com&utm_medium=studygolang.com&utm_medium=studygolang.com&utm_source=studygolang.com?utm_campaign=studygolang.com&utm_source=studygolang.com">搞懂Go垃圾回收</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;搞懂Go垃圾回收&quot;&gt;&lt;a href=&quot;#搞懂Go垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;搞懂Go垃圾回收&quot;&gt;&lt;/a&gt;搞懂Go垃圾回收&lt;/h1&gt;&lt;p&gt;本文主要介绍了垃圾回收的概念，Golang GC的垃圾回收算法和工作原理，看完本文可以让你对</summary>
      
    
    
    
    <category term="开发" scheme="http://gonejack.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="golang" scheme="http://gonejack.github.io/tags/golang/"/>
    
    <category term="内存管理" scheme="http://gonejack.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>go程序初始化顺序</title>
    <link href="http://gonejack.github.io/2020/12/01/%E6%8A%80%E6%9C%AF/go%E7%A8%8B%E5%BA%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/"/>
    <id>http://gonejack.github.io/2020/12/01/%E6%8A%80%E6%9C%AF/go%E7%A8%8B%E5%BA%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/</id>
    <published>2020-12-01T04:51:14.000Z</published>
    <updated>2020-12-01T04:58:19.193Z</updated>
    
    <content type="html"><![CDATA[<p>在一个 go 程序中通常包含：包、常量、变量、init()、main()等元素，如果同时存在多个包，包之间存在依赖关系，每个包中存在多个 init 函数，每个文件中存在多个 init 函数，那么问题来了，他们之间的执行顺序是什么样的？通过本文我们来对它们之间的执行顺序做尽可能详尽的说明。如有不正之处，欢迎批评指正。</p><h3 id="包的执行顺序"><a href="#包的执行顺序" class="headerlink" title="包的执行顺序"></a>包的执行顺序</h3><ul><li>在 main 包中的 go 文件默认总是会被执行</li><li>同包下的不同 go 文件，按照文件名“从小到大”排序顺序执行</li><li>其他的包只有被 main 包 import 才会执行，按照 import 的先后顺序执行</li><li>被递归 import 的包的初始化顺序与 import 顺序相反，例如：导入顺序 main –&gt; A –&gt; B –&gt; C，则初始化顺序为 C –&gt; B –&gt; A –&gt; main</li><li>一个包被其它多个包 import，但只能被初始化一次</li><li>main 包总是被最后一个初始化，因为它总是依赖别的包</li><li>避免出现循环 import，例如：A –&gt; B –&gt; C –&gt; A</li></ul><p>go 程序的初始化顺序见下图：</p><p><img src="assets/20170831112523944.jpeg"></p><h3 id="init-和-main-函数"><a href="#init-和-main-函数" class="headerlink" title="init 和 main 函数"></a>init 和 main 函数</h3><p>init()、main() 是 go 语言中的保留函数，两个函数在 go 语言中的区别如下：<br>相同点：</p><ul><li>两个函数在定义时不能有任何的参数和返回值</li><li>该函数只能由 go 程序自动调用，不可以被引用</li></ul><p>不同点：</p><ul><li>init 可以应用于任意包中，且可以重复定义多个。</li><li>main 函数只能用于 main 包中，且只能定义一个。</li></ul><p>两个函数的执行顺序：</p><ul><li>对同一个 go 文件的 init( ) 调用顺序是从上到下的</li><li>对同一个 package 中的不同文件，将文件名按字符串进行“从小到大”排序，之后顺序调用各文件中的init()函数</li><li>对于不同的 package，如果不相互依赖的话，按照 main 包中 import 的顺序调用其包中的 init() 函数</li><li>如果 package 存在依赖，调用顺序为最后被依赖的最先被初始化，例如：导入顺序 main –&gt; A –&gt; B –&gt; C，则初始化顺序为 C –&gt; B –&gt; A –&gt; main，一次执行对应的 init 方法。</li></ul><h3 id="常量、变量、init-、main"><a href="#常量、变量、init-、main" class="headerlink" title="常量、变量、init()、main()"></a>常量、变量、init()、main()</h3><p>在同一个文件中，常量、变量、init()、main() 依次进行初始化。</p><p><a href="https://blog.csdn.net/claram/article/details/77745665">go编程：浅析go程序初始化顺序</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在一个 go 程序中通常包含：包、常量、变量、init()、main()等元素，如果同时存在多个包，包之间存在依赖关系，每个包中存在多个 init 函数，每个文件中存在多个 init 函数，那么问题来了，他们之间的执行顺序是什么样的？通过本文我们来对它们之间的执行顺序做尽可</summary>
      
    
    
    
    <category term="开发" scheme="http://gonejack.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="golang" scheme="http://gonejack.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>解决git status不能显示中文</title>
    <link href="http://gonejack.github.io/2020/12/01/%E6%8A%80%E6%9C%AF/git-show-chinese-filenames/"/>
    <id>http://gonejack.github.io/2020/12/01/%E6%8A%80%E6%9C%AF/git-show-chinese-filenames/</id>
    <published>2020-12-01T04:39:34.000Z</published>
    <updated>2020-12-01T04:45:30.015Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>现象<br>status查看有改动但未提交的文件时总只显示数字串，显示不出中文文件名，非常不方便。如下图：<br><img src="assets/status-dig.jpg"></p></li><li><p>原因<br>在默认设置下，中文文件名在工作区状态输出，中文名不能正确显示，而是显示为八进制的字符编码。</p></li><li><p>解决办法<br>将git 配置文件 core.quotepath项设置为false</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config —global core.quotepath false</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;现象&lt;br&gt;status查看有改动但未提交的文件时总只显示数字串，显示不出中文文件名，非常不方便。如下图：&lt;br&gt;&lt;img src=&quot;assets/status-dig.jpg&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原因&lt;br&gt;在默认设置下，中文文件名在工</summary>
      
    
    
    
    <category term="技术" scheme="http://gonejack.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="git" scheme="http://gonejack.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Chrome 87 新功能：标签页分组，可自动分组同网站下标签页</title>
    <link href="http://gonejack.github.io/2020/12/01/%E5%B7%A5%E5%85%B7/chrome_87_%E6%96%B0%E5%8A%9F%E8%83%BD/"/>
    <id>http://gonejack.github.io/2020/12/01/%E5%B7%A5%E5%85%B7/chrome_87_%E6%96%B0%E5%8A%9F%E8%83%BD/</id>
    <published>2020-12-01T03:59:36.000Z</published>
    <updated>2020-12-01T04:13:26.116Z</updated>
    
    <content type="html"><![CDATA[<p>2020 年的最后一个版本 <a href="https://www.appinn.com/chrome-87-released/">Chrome 87</a> 新增了很多实用性的功能，在支持 <a href="https://www.appinn.com/chrome-87-search-tabs-in-addressbar/">地址栏切换标签页</a> 之后， <strong>标签页分组</strong> 功能页正式上线了，并且还可以为 <strong>同网站</strong> 自动创建标签页分组。@Appinn </p><p><img src="assets/image1.jpeg"></p><p>倒也不是吹捧，见过这么多分组扩展，青小蛙的确觉得 Chrome 官方的标签页分组方式更科学一些。</p><h2 id="标签页分组"><a href="#标签页分组" class="headerlink" title="标签页分组"></a>标签页分组</h2><p>升级至 Chrome 87 最新版本之后，就自动拥有了这个功能，只需要对着标签页右键，选择 <strong>向新群组中添加标签页</strong> ，即可创建分组： </p><p><img src="assets/image2.jpeg"></p><p>之后便可在其他标签页标题右键时，同样选择 <strong>向新群组中添加标签页</strong> 就能移动至分组中： </p><p><img src="assets/image3.jpeg"></p><p>之后，还可以对分组命名，并标记颜色，如果未命名，分组将以小圆点的方式表示，命名后就如下图，点击该名称还能折叠分组：</p><p><img src="assets/image4.jpeg"></p><h2 id="自动分组"><a href="#自动分组" class="headerlink" title="自动分组"></a>自动分组</h2><p>自动分组目前还属于实验性功能，需要在 Chrome://flags 中开启：</p><p><img src="assets/image5.jpeg"></p><p>开启后，新打开的标签页如果是同网站下，就会自动创建分组。</p><hr><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><ul><li><a href="https://www.appinn.com/lzzxt-game4/">3000时代来临，赢空间活动继续</a></li><li><a href="https://www.appinn.com/chrome-4-extensions-setup/">Chrome 4.0，用扩展武装它</a></li><li><a href="https://www.appinn.com/save-pinned-tabs-for-chrome/">Save Pinned Tabs – 保存 Chrome 当前固定标签页、分组、同步</a></li><li><a href="https://www.appinn.com/lzzxt-game3/">赢空间游戏新高 3432 分</a></li><li><a href="https://www.appinn.com/automatic-scrolling-tabs-for-chrome/">求一个脱离鼠标仍可网页自动向下滚动的 Chrome 插件</a></li></ul><hr><p><a href="http://www.appinn.com/copyright/?&amp;&amp;">©</a> 2019 青小蛙 for <a href="http://www.appinn.com/?&amp;&amp;">小众软件</a> | <a href="http://www.appinn.com/join-us/?&amp;&amp;">加入我们</a> | <a href="https://meta.appinn.com/c/faxian/?&amp;&amp;">投稿</a> | <a href="http://www.appinn.com/feeds-subscribe/?&amp;&amp;">订阅指南</a><br>3659b075e72a5b7b1b87ea74aa7932ff<br><a href="https://www.appinn.com/chrome-87-tabs-group/#comments">点击这里留言、和原作者一起评论</a> <a href="https://www.appinn.com/chrome-87-tabs-group/">https://www.appinn.com/chrome-87-tabs-group/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2020 年的最后一个版本 &lt;a href=&quot;https://www.appinn.com/chrome-87-released/&quot;&gt;Chrome 87&lt;/a&gt; 新增了很多实用性的功能，在支持 &lt;a href=&quot;https://www.appinn.com/chrome-8</summary>
      
    
    
    
    <category term="新闻记录" scheme="http://gonejack.github.io/categories/%E6%96%B0%E9%97%BB%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="chrome" scheme="http://gonejack.github.io/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://gonejack.github.io/2020/11/14/hello-world/"/>
    <id>http://gonejack.github.io/2020/11/14/hello-world/</id>
    <published>2020-11-14T20:37:58.507Z</published>
    <updated>2020-11-14T20:37:58.508Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
